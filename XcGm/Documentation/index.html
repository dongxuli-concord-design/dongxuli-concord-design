<html>
<meta charset="UTF-8">
<head>
  <title>Documentation</title>
  <link href="../bootstrap.css" rel="stylesheet" type="text/css">
  <meta content="width=device-width, initial-scale=1.0, user-scalable=no" name="viewport">
</head>
<body style="margin: 10px;">

<h1>Introduction</h1>
<p>Geometric modeling library</p>

<h1>XcGmAssert</h1>
<p><code>function XcGmAssert({assertion, message = 'Unknown'})</code></p>

<h1>XcGm2dPosition</h1>
<p><code>class XcGm2dPosition</code></p>
<p>Represents a 2D position.</p>

<h2>constructor</h2>
<p><code>constructor({x = 0.0, y = 0.0} = {})</code></p>
<dl>

  <dt>x</dt>
  <dd>A floating number representing X coordinate.</dd>


  <dt>y</dt>
  <dd>A floating number representing Y coordinate.</dd>

</dl>

<h2>fromArray</h2>
<p><code>static fromArray({array})</code></p>
<dl>

  <dt>array</dt>
  <dd>Array in the <code>[x, y]</code> form.</dd>


  <dt>return</dt>
  <dd><code>XcGm2dPosition</code> object</dd>

</dl>
<p>Constructs a XcGm2dPosition object from an array.</p>

<h2>fromJSON</h2>
<p><code>static fromJSON({json})</code></p>
<dl>

  <dt>json</dt>
  <dd>json object in the <code>{x, y}</code> form.</dd>


  <dt>return</dt>
  <dd><code>XcGm2dPosition</code> object</dd>

</dl>
<p>Constructs a <code>XcGm2dPosition</code> object from a json object.</p>

<h2>fromThreeVector2</h2>
<p><code>static fromThreeVector2({threeVector2})</code></p>
<dl>

  <dt>threeVector2</dt>
  <dd>Three.js Vector2 object.</dd>


  <dt>return</dt>
  <dd>XcGm2dPosition object</dd>

</dl>
<p>Constructs a <code>XcGm2dPosition</code> object from a Three.js Vector2 object.</p>

<h2>toThreeVector2</h2>
<p><code>toThreeVector2</code></p>
<dl>

  <dt>return</dt>
  <dd>Three.js Vector2 object</dd>

</dl>
<p>Constructs a Three.js Vector2 object from this <code>XcGm2dPosition</code> object.</p>

<h2>toString</h2>
<p><code>toString()</code></p>
<dl>

  <dt>return</dt>
  <dd>String representation of the object.</dd>

</dl>

<h2>toArray</h2>
<p><code>toArray()</code></p>
<dl>

  <dt>return</dt>
  <dd>Array representation of the object.</dd>

</dl>

<h2>toJSON</h2>
<p><code>toJSON()</code></p>
<dl>

  <dt>return</dt>
  <dd>Json representation of the object.</dd>

</dl>

<h2>clone</h2>
<p><code>clone()</code></p>
<dl>

  <dt>return</dt>
  <dd>XcGm2dPosition which is cloned from the object.</dd>

</dl>

<h2>copy</h2>
<p><code>copy({position})</code></p>
<dl>

  <dt>position</dt>
  <dd>Another XcGm2dPosition object.</dd>

</dl>
<p>Set the object value from another <code>XcGm2dPosition</code> object.</p>

<h1>XcGm2dVector</h1>
<p><code>class XcGm2dVector</code></p>
<p>Represents a 2D vector.</p>

<h2>constructor</h2>
<p><code>constructor({x = 0.0, y = 0.0} = {})</code></p>
<dl>

  <dt>x</dt>
  <dd>A floating number representing X coordinate.</dd>


  <dt>y</dt>
  <dd>A floating number representing Y coordinate.</dd>

</dl>

<h2>fromArray</h2>
<p><code>static fromArray({array})</code></p>
<dl>

  <dt>array</dt>
  <dd>Array in the <code>[x, y]</code> form.</dd>


  <dt>return</dt>
  <dd>XcGm2dVector object</dd>

</dl>
<p>Constructs a <code>XcGm2dVector</code> object from an array.</p>

<h2>fromJSON</h2>
<p><code>static fromJSON({json})</code></p>
<dl>

  <dt>json</dt>
  <dd>json object in the <code>{x, y}</code> form.</dd>


  <dt>return</dt>
  <dd>XcGm2dVector object</dd>

</dl>
<p>Constructs a <code>XcGm2dVector</code> object from a json object.</p>

<h2>fromThreeVector2</h2>
<p><code>static fromThreeVector2({threeVector2})</code></p>
<dl>

  <dt>threeVector2</dt>
  <dd>Three.js Vector2 object.</dd>


  <dt>return</dt>
  <dd>XcGm2dVector object</dd>

</dl>
<p>Constructs a <code>XcGm2dVector</code> object from a Three.js Vector2 object.</p>

<h2>toThreeVector2</h2>
<p><code>toThreeVector2</code></p>
<dl>

  <dt>return</dt>
  <dd>Three.js Vector2 object</dd>

</dl>
<p>Constructs a Three.js Vector2 object from this <code>XcGm2dVector</code> object.</p>

<h2>toString</h2>
<p><code>toString()</code></p>
<dl>

  <dt>return</dt>
  <dd>String representation of the object.</dd>

</dl>

<h2>toArray</h2>
<p><code>toArray()</code></p>
<dl>

  <dt>return</dt>
  <dd>Array representation of the object.</dd>

</dl>

<h2>toJSON</h2>
<p><code>toJSON()</code></p>
<dl>

  <dt>return</dt>
  <dd>Json representation of the object.</dd>

</dl>

<h2>clone</h2>
<p><code>clone()</code></p>
<dl>

  <dt>return</dt>
  <dd><code>XcGm2dVector</code> object which is cloned from the object.</dd>

</dl>

<h2>copy</h2>
<p><code>copy({vector})</code></p>
<dl>

  <dt>vector</dt>
  <dd><code>XcGm2dVector</code> object.</dd>

</dl>
<p>Set the object value from another <code>XcGm2dVector</code> object.</p>

<h1>XcGm3dBCurve</h1>
<p><code>class XcGm3dCurve extends XcGmGeometry</code></p>
<p>Represents 3D BCurve.</p>

<h1>XcGm2dAxis</h1>
<p><code>class XcGm2dAxis</code></p>

<h2>position</h2>
<p><code>position</code></p>
<p>XcGm2dPosition object</p>

<h2>direction</h2>
<p><code>direction</code></p>
<p>XcGm2dVector object</p>

<h2>constructor</h2>
<pre><code>constructor({
                position = new XcGm2dPosition(),
                direction = new XcGm2dVector({x: 0, y: 0, z: 1})
              } = {})
</code></pre>

<h2>toJSON</h2>
<p><code>toJSON()</code></p>

<h2>fromJSON</h2>
<p><code>fromJSON({json})</code></p>

<h1>XcGm3dCircle</h1>
<p><code>class XcGm3dCircle extends XcGm3dCurve</code></p>

<h2>radius</h2>
<p><code>get radius()</code></p>
<dl>

  <dt>return</dt>
  <dd>Return the radius value.</dd>

</dl>
<p>Return the radius of the object.</p>

<h2>XcGmEulerAngles</h2>
<p>// TODO</p>

<h2>coordinateSystem</h2>
<p><code>get coordinateSystem()</code></p>

<dl>

  <dt>return</dt>
  <dd><code>XcGmCoordinateSystem</code> object.</dd>

</dl>

<p>Return <code>XcGmCoordinateSystem</code> object of the object.</p>

<h2>create</h2>
<p><code>static create({radius, coordinateSystem})</code></p>
<dl>

  <dt>radius</dt>
  <dd>Radius value.</dd>


  <dt>coordinateSystem</dt>
  <dd>XcGmCoordinateSystem object of the object.</dd>


  <dt>return</dt>
  <dd>XcGm3dCircle object</dd>

</dl>
<p>Create a XcGm3dCircle object from provided radius and coordinate system.</p>

<h1>XcGm3dEllipse</h1>
<p><code>class XcGm3dEllipse extends XcGm3dCurve</code></p>
<p>Represents a 3D Ellipse.</p>

<h1>XcGm3dCurve</h1>
<p><code>class XcGm3dCurve extends XcGmGeometry</code></p>

<h2>makeWireBodyFromCurves</h2>
<p><code>static makeWireBodyFromCurves({curves, bounds})</code></p>
<p>Example</p>
<pre><code>      let position = new XcGm3dPosition();
      let direction = new XcGm3dVector({x: 1, y: 1, z: 0});
      let axis = new XcGm3dAxis({position, direction});
      let line = XcGm3dLine.create({axis});
      let bound = new XcGmInterval({low: 0, high: 10})});
      let {wire} = XcGm3dCurve.makeWireBodyFromCurves({curves: [line], bounds: [bound]});
</code></pre>

<h1>XcGm3dLine</h1>
<p><code>class XcGm3dLine extends XcGm3dCurve</code></p>
<p>Represents a 3D line.</p>

<h2>axis</h2>
<p><code>get axis()</code></p>
<dl>

  <dt>return</dt>
  <dd><code>XcGm3dAxis</code> object representing the axis of the 3D line.</dd>

</dl>
<p>Get the axis of the 3D line.</p>

<h2>create</h2>
<p><code>static create({axis})</code></p>
<dl>

  <dt>axis</dt>
  <dd><code>XcGm3dAxis</code> object representing the axis of the 3D line.</dd>


  <dt>return</dt>
  <dd><code>XcGm3dLine</code> object.</dd>

</dl>
<p>Creates a XcGm3dLine object from the provided axis.</p>

<h1>XcGm3dMatrix</h1>
<p><code>class XcGm3dMatrix</code></p>
<p>Represents a 3D matrix, which is a 4 by 4 matrix.</p>

<h2>identity</h2>
<p><code>static get identity()</code></p>
<dl>
  *<em>return</em> XcGm3dMatrix object</dd>
</dl>
<p>Constructs a 4 by 4 identity matrix.</p>

<h2>fromArray</h2>
<p><code>static fromArray({array})</code></p>
<dl>

  <dt>array</dt>
  <dd>Array representation of the matrix.</dd>

  *<em>return</em> XcGm3dMatrix object.</dd>
</dl>
<p>Constructs a <code>XcGm3dMatrix</code> object from the array representation.</p>

<h2>multiply</h2>
<p><code>static multiply({matrix1, matrix2})</code></p>
<dl>

  <dt>matrix1</dt>
  <dd>First matrix.</dd>


  <dt>matrix2</dt>
  <dd>Second matrix.</dd>

  *<em>return</em> XcGm3dMatrix object</dd>
</dl>
<p>Constructs a <code>XcGm3dMatrix</code> object from <code>matrix1 x matrix2</code>.</p>

<h2>translationMatrix</h2>
<p><code>static translationMatrix({vector})</code></p>
<dl>

  <dt>vector</dt>
  <dd>XcGm3dVector object.</dd>

  *<em>return</em> XcGm3dMatrix object</dd>
</dl>
<p>Constructs a <code>XcGm3dMatrix</code> object representing a translation.</p>

<h2>rotationMatrix</h2>
<p><code>static rotationMatrix({angle, axis})</code></p>
<dl>

  <dt>angle</dt>
  <dd>A floating point number representing rotation angle.</dd>


  <dt>axis</dt>
  <dd>XcGm3dAxis representing rotation axis.</dd>

  *<em>return</em> XcGm3dMatrix object</dd>
</dl>
<p>Constructs a <code>XcGm3dMatrix</code> object representing a rotation around an axis.</p>

<h2>scalingMatrix</h2>
<p><code>static scalingMatrix({scale, center})</code></p>
<dl>

  <dt>scale</dt>
  <dd>A floating point number representing scaling factor.</dd>


  <dt>center</dt>
  <dd>XcGm3dPosition representing scale center.</dd>

  *<em>return</em> XcGm3dMatrix object</dd>
</dl>
<p>Constructs a <code>XcGm3dMatrix</code> object representing a scale relative to the center.</p>

<h2>mirroringOverPositionMatrix</h2>
<p><code>static mirroringOverPositionMatrix({position})</code></p>
<dl>

  <dt>position</dt>
  <dd>XcGm3dPosition representing mirror position.</dd>

  *<em>return</em> XcGm3dMatrix object</dd>
</dl>
<p>Constructs a <code>XcGm3dMatrix</code> object representing a mirror transform relative to the position.</p>

<h2>mirroringOverPlaneMatrix</h2>
<p><code>static mirroringOverPlaneMatrix({line})</code></p>
<dl>

  <dt>line</dt>
  <dd>XcGm3dAxis representing mirror line.</dd>


  <dt>return</dt>
  <dd>XcGm3dMatrix object</dd>

</dl>
<p>Constructs a <code>XcGm3dMatrix</code> object representing a mirror transform relative to the line.</p>

<h2>fromThreeMatrix4</h2>
<p><code>static fromThreeMatrix4({threeMatrix4})</code><br>
  //TODO</p>

<h2>rotationMatrixFromEulerAngles</h2>
<p><code>static rotationMatrixFromEulerAngles({eulerAngles})</code></p>

<h2>setToThreeMatrix4</h2>
<p><code>setToThreeMatrix4({threeMatrix4})</code></p>

<h2>setToRotationMatrixFromEulerAngles</h2>
<p><code>setToRotationMatrixFromEulerAngles({eulerAngles})</code></p>

<h2>toArray</h2>
<p><code>toArray()</code></p>
<dl>

  <dt>return</dt>
  <dd>Array representation of the object.</dd>

</dl>

<h2>toJSON</h2>
<p><code>toJSON()</code></p>
<dl>

  <dt>return</dt>
  <dd>Json representation of the object.</dd>

</dl>

<h2>clone</h2>
<p><code>clone()</code></p>
<dl>

  <dt>return</dt>
  <dd><code>XcGm3dMatrix</code> object which is cloned from the object.</dd>

</dl>

<h2>copy</h2>
<p><code>copy({matrix})</code></p>
<dl>

  <dt>matrix</dt>
  <dd><code>XcGm3dMatrix</code> object.</dd>

</dl>
<p>Set the object value from another <code>XcGm3dMatrix</code> object.</p>

<h2>get</h2>
<p><code>get({row, column})</code></p>
<dl>

  <dt>row</dt>
  <dd>Integer number representing the row index.</dd>


  <dt>column</dt>
  <dd>Integer number representing the column index.</dd>


  <dt>return</dt>
  <dd>A floating point number representing the matrix element value.</dd>

</dl>
<p>Get the matrix element value at the <code>[row, column]</code>.</p>

<h2>setToIdentity</h2>
<p><code>setToIdentity()</code></p>
<p>Set this matrix to identity.</p>

<h2>multiplyScalar</h2>
<p><code>multiplyScalar({scale})</code></p>
<dl>

  <dt>scale</dt>
  <dd>A floating point number representing scaling factor</dd>

</dl>
<p>Scale the matrix using the provided factor.</p>

<h2>multiply</h2>
<p><code>multiply({matrix})</code></p>
<dl>

  <dt>matrix</dt>
  <dd><code>XcGm3dMatrix</code> object.</dd>

</dl>
<p>Do this × matrix.</p>

<h2>preMultiply</h2>
<p><code>preMultiply({matrix})</code></p>
<dl>

  <dt>matrix</dt>
  <dd><code>XcGm3dMatrix</code> object.</dd>

</dl>
<p>Do matrix × this.</p>

<h2>setToProduct</h2>
<p><code>setToProduct({matrix1, matrix2})</code></p>
<dl>

  <dt>matrix1</dt>
  <dd><code>XcGm3dMatrix</code> object.</dd>


  <dt>matrix2</dt>
  <dd><code>XcGm3dMatrix</code> object.</dd>

</dl>
<p>Set the object value to the product of the provided matrix1 and matrix2.</p>

<h2>invert</h2>
<p><code>invert()</code></p>
<p>Invert this matrix.</p>

<h2>inverse</h2>
<p><code>get inverse()</code></p>
<dl>

  <dt>return</dt>
  <dd><code>XcGm3dMatrix</code> object.</dd>

</dl>
<p>Return the inverse of this matrix.</p>

<h2>isSingular</h2>
<p><code>isSingular()</code></p>
<dl>

  <dt>return</dt>
  <dd>Boolean value to indicate if the matrix is singular.</dd>

</dl>

<h2>transpose</h2>
<p><code>transpose()</code></p>
<p>Transpose the matrix.</p>

<h2>transposition</h2>
<p><code>transposition()</code></p>
<dl>

  <dt>return</dt>
  <dd><code>XcGm3dMatrix</code> object.</dd>

</dl>
<p>Return the transposition of the object.</p>

<h2>isEqualTo</h2>
<p><code>isEqualTo({matrix})</code></p>
<dl>

  <dt>return</dt>
  <dd>Boolean value to indicate if the matrix is equal to the provided matrix.</dd>

</dl>
<p>Check if this matrix is equal to another matrix.</p>

<h2>determinant</h2>
<p><code>determinant()</code></p>
<dl>

  <dt>return</dt>
  <dd>A floating number representing matrix determinant.</dd>

</dl>
<p>Calculate the determinant value.</p>

<h2>setTranslationVector</h2>
<p><code>setTranslationVector({vector})</code></p>
<dl>

  <dt>vector</dt>
  <dd><code>XcGm3dVector</code> object representing the translation vector.</dd>

</dl>
<p>Set the translation part values of the matrix.</p>

<h2>translationVector</h2>
<p><code>translationVector()</code></p>
<dl>

  <dt>return</dt>
  <dd><code>XcGm3dVector</code> object representing the translation vector.</dd>

</dl>
<p>Get the translation part of the matrix.</p>

<h2>setToTranslation</h2>
<p><code>setToTranslation({vector})</code></p>
<dl>

  <dt>vector</dt>
  <dd><code>XcGm3dVector</code> object representing the translation vector.</dd>

</dl>
<p>Set the matrix representing a translation.</p>

<h2>setToRotation</h2>
<p><code>setToRotation({angle, axis})</code></p>
<dl>

  <dt>angle</dt>
  <dd>A floating number representing the rotation angle.</dd>


  <dt>axis</dt>
  <dd><code>XcGm3dAxis</code> object representing the rotation axis.</dd>

</dl>
<p>Set the matrix representing a rotation.</p>

<h2>setToNonUniformScaling</h2>
<p><code>setToNonUniformScaling({scaleX, scaleY, scaleZ, center})</code></p>
<dl>

  <dt>scaleX</dt>
  <dd>A floating number representing the scaling factor on X.</dd>


  <dt>scaleY</dt>
  <dd>A floating number representing the scaling factor on Y.</dd>


  <dt>scaleZ</dt>
  <dd>A floating number representing the scaling factor on Z.</dd>


  <dt>center</dt>
  <dd><code>XcGm3dPosition</code> object representing the scaling center.</dd>

</dl>
<p>Set the matrix representing a non-uniform scaling.</p>

<h2>setToScaling</h2>
<p><code>setToScaling({scale, center})</code></p>
<dl>

  <dt>scale</dt>
  <dd>A floating number representing the scaling factor.</dd>


  <dt>center</dt>
  <dd><code>XcGm3dPosition</code> object representing the scaling center.</dd>

</dl>
<p>Set the matrix representing a uniform scaling.</p>

<h2>toThreeMatrix4</h2>
<p><code>toThreeMatrix4()</code></p>
<dl>

  <dt>return</dt>
  <dd>A Three.js matrix4</dd>

</dl>
<p>Get the Three.js matrix representation of the object.</p>

<h2>lerpTo</h2>
<p><code>lerpTo({targetMatrix, scale})</code></p>
<dl>

  <dt>return</dt>
  <dd>A linear interpolation of between the current matrix to the target matrix.</dd>


  <dt>targetMatrix</dt>
  <dd>target matrix</dd>


  <dt>scale</dt>
  <dd>the interpolation parameter, expected range from 0 to 1, the result is a weighted
    average.<br>
    If scale=0, the result is the current matrix;<br>
    if scale=1, the result is targetMatrix
  </dd>

</dl>
<p>linear interpolation of position and orientation. The matrices are assumed to be rigid transform matrices, i.e.
  rotation<br>
  and translation only</p>

<h1>XcGm3dPoint</h1>
<p><code>class XcGm3dPoint extends XcGmGeometry</code></p>

<h2>constructor()</h2>
<p><code>constructor()</code></p>

<h2>position</h2>
<p><code>get position()</code></p>
<dl>

  <dt>return</dt>
  <dd><code>XcGm3dPosition</code> object of the point object.</dd>

</dl>
<p>Get the position of the object.</p>

<h2>part</h2>
<p><code>get part()</code></p>
<dl>

  <dt>return</dt>
  <dd><code>XcGmPart</code> object of the point object.</dd>

</dl>
<p>This function returns the part which owns the given point, if there is one, otherwise null.</p>
<p>The point may either be attached directly to a vertex of a body, or be construction geometry in a part.</p>

<h2>vertex</h2>
<p><code>get vertex()</code></p>

<h2>create</h2>
<p><code>static create({position})</code></p>

<h2>createMinimumBody</h2>
<p><code>createMinimumBody()</code></p>

<h1>XcGm3dPosition</h1>
<p><code>class XcGm3dPosition</code></p>

<h2>constructor</h2>
<p><code>constructor({x = 0.0, y = 0.0, z = 0.0} = {})</code></p>
<dl>

  <dt>x</dt>
  <dd>A floating number representing X coordinate.</dd>


  <dt>y</dt>
  <dd>A floating number representing Y coordinate.</dd>


  <dt>z</dt>
  <dd>A floating number representing Z coordinate.</dd>

</dl>

<h2>origin</h2>
<p><code>static get origin()</code></p>
<dl>

  <dt>return</dt>
  <dd>A new <code>XcGm3dPosition</code> object at the origin.</dd>

</dl>

<h2>fromArray</h2>
<p><code>static fromArray({array})</code></p>
<dl>

  <dt>array</dt>
  <dd>Array in the <code>[x, y, z]</code> form.</dd>


  <dt>return</dt>
  <dd>XcGm3dPosition object.</dd>

</dl>
<p>Constructs a <code>XcGm3dPosition</code> object from an array.</p>

<h2>fromJSON</h2>
<p><code>static fromJSON({json})</code></p>
<dl>

  <dt>json</dt>
  <dd>json object in the <code>{x, y}</code> form.</dd>


  <dt>return</dt>
  <dd><code>XcGm3dPosition</code> object.</dd>

</dl>
<p>Constructs a <code>XcGm3dPosition</code> object from a json object.</p>

<h2>add</h2>
<p><code>static add({position, vector})</code></p>
<dl>

  <dt>position</dt>
  <dd><code>XcGm3dPosition</code> object.</dd>


  <dt>vector</dt>
  <dd><code>XcGm3dVector</code> object.</dd>


  <dt>return</dt>
  <dd>A <code>XcGm3dPosition</code> object representing the <code>position + vector</code>.</dd>

</dl>

<h2>subtract</h2>
<p><code>static subtract({position, positionOrVector})</code></p>
<dl>

  <dt>position</dt>
  <dd><code>XcGm3dPosition</code> object.</dd>


  <dt>positionOrVector</dt>
  <dd><code>XcGm3dVector</code> or <code>XcGm3dPosition</code> object.</dd>


  <dt>return</dt>
  <dd>A <code>XcGm3dPosition</code> object representing the <code>position -
    positionOrVector</code>.
  </dd>

</dl>

<h2>multiply</h2>
<p><code>static multiply({position, scale})</code></p>
<dl>

  <dt>position</dt>
  <dd><code>XcGm3dPosition</code> object.</dd>


  <dt>scale</dt>
  <dd>A floating representing scaling factor.</dd>


  <dt>return</dt>
  <dd>A <code>XcGm3dPosition</code> object representing the <code>position * scale</code>.</dd>

</dl>

<h2>divide</h2>
<p><code>static divide({position, scale})</code></p>
<dl>

  <dt>position</dt>
  <dd><code>XcGm3dPosition</code> object.</dd>


  <dt>scale</dt>
  <dd>A floating representing scaling factor.</dd>


  <dt>return</dt>
  <dd>A <code>XcGm3dPosition</code> object representing the <code>position / scale</code>.</dd>

</dl>

<h2>fromThreeVector3</h2>
<p><code>static fromThreeVector3({threeVector3})</code></p>
<dl>

  <dt>threeVector3</dt>
  <dd>Three.js Vector3 object.</dd>


  <dt>return</dt>
  <dd>XcGm3dPosition object</dd>

</dl>
<p>Constructs a <code>XcGm3dPosition</code> object from a Three.js Vector3 object.</p>

<h2>toThreeVector3</h2>
<p><code>toThreeVector3()</code></p>
<dl>

  <dt>return</dt>
  <dd>Three.js Vector3 object.</dd>

</dl>
<p>Constructs a Three.js Vector3 object representing the object.</p>

<h2>toString</h2>
<p><code>toString()</code></p>
<dl>

  <dt>return</dt>
  <dd>String representation of the object.</dd>

</dl>

<h2>toArray</h2>
<p><code>toArray()</code></p>
<dl>

  <dt>return</dt>
  <dd>Array representation of the object.</dd>

</dl>

<h2>toJSON</h2>
<p><code>toJSON()</code></p>
<dl>

  <dt>return</dt>
  <dd>Json representation of the object.</dd>

</dl>

<h2>clone</h2>
<p><code>clone()</code></p>
<dl>

  <dt>return</dt>
  <dd><code>XcGm3dPosition</code> object which is cloned from the object.</dd>

</dl>

<h2>copy</h2>
<p><code>copy({position})</code></p>
<dl>

  <dt>position</dt>
  <dd><code>XcGm3dPosition</code> object.</dd>

</dl>
<p>Set the object value from another <code>XcGm3dPosition</code> object.</p>

<h2>add</h2>
<p><code>add({vector})</code></p>
<dl>

  <dt>vector</dt>
  <dd><code>XcGm3dVector</code> object.</dd>

</dl>
<p>Add the object to the given vector.</p>

<h2>subtract</h2>
<p><code>subtract({positionOrVector})</code></p>
<dl>

  <dt>positionOrVector</dt>
  <dd><code>XcGm3dVector</code> or <code>XcGm3dPosition</code> object.</dd>

</dl>
<p>Subtract the object to the given position or vector.</p>

<h2>multiply</h2>
<p><code>multiply({scale})</code></p>
<dl>

  <dt>scale</dt>
  <dd>A floating representing scaling factor.</dd>

</dl>
<p>Multiply the object to the given scaling factor.</p>

<h2>divide</h2>
<p><code>divide({scale})</code></p>
<dl>

  <dt>scale</dt>
  <dd>A floating representing scaling factor.</dd>

</dl>
<p>Divide the object to the given scaling factor.</p>

<h2>toVector</h2>
<p><code>toVector()</code></p>
<dl>

  <dt>return</dt>
  <dd><code>XcGm3dVector</code> object which has the same X/Y/Z values.</dd>

</dl>

<h2>set</h2>
<p><code>set({x, y, z})</code></p>
<dl>

  <dt>x</dt>
  <dd>A floating number representing X coordinate.</dd>


  <dt>y</dt>
  <dd>A floating number representing Y coordinate.</dd>


  <dt>z</dt>
  <dd>A floating number representing Z coordinate.</dd>

</dl>
<p>Set the object value with the provided values.</p>

<h2>setToSum</h2>
<p><code>setToSum({position, vector})</code></p>
<dl>

  <dt>position</dt>
  <dd><code>XcGm3dPosition</code> object.</dd>


  <dt>vector</dt>
  <dd><code>XcGm3dVector</code> object.</dd>

</dl>

<h2>setToProduct</h2>
<p><code>setToProduct({matrix, position})</code></p>
<dl>

  <dt>matrix</dt>
  <dd><code>XcGm3dMatrix</code> object.</dd>


  <dt>position</dt>
  <dd><code>XcGm3dPosition</code> object.</dd>

</dl>
<p>Set the object value to the product of the provided matrix and position.</p>

<h2>transformBy</h2>
<p><code>transformBy({matrix})</code></p>
<dl>

  <dt>matrix</dt>
  <dd><code>XcGm3dMatrix</code> object</dd>

</dl>
<p>Transform the object with the provided matrix.</p>

<h2>distanceToPosition</h2>
<p><code>distanceToPosition({position})</code></p>
<dl>

  <dt>position</dt>
  <dd><code>XcGm3dPosition</code> object.</dd>

  *<em>return</em> A floating number representing the distance between the object and the provided position.</dd>

</dl>

<h2>isEqualTo</h2>
<p><code>isEqualTo({position})</code></p>
<dl>

  <dt>position</dt>
  <dd><code>XcGm3dPosition</code> object.</dd>


  <dt>return</dt>
  <dd>Boolean value representing if the object is equal to the provided position.</dd>

</dl>

<h1>XcGm3dVector</h1>
<p><code>class XcGm3dVector</code></p>
<p>This class represents a 3D vector.</p>

<h2>constructor</h2>
<p><code>constructor({x = 0.0, y = 0.0, z = 0.0} = {})</code></p>
<dl>

  <dt>x</dt>
  <dd>A floating number representing X coordinate.</dd>


  <dt>y</dt>
  <dd>A floating number representing Y coordinate.</dd>


  <dt>z</dt>
  <dd>A floating number representing Z coordinate.</dd>

</dl>

<h2>identity</h2>
<p><code>static get identity()</code></p>
<dl>

  <dt>return</dt>
  <dd><code>XcGm3dVector</code> vector.</dd>

</dl>
<p>Return a new <code>XcGm3dVector({x: 0.0, y: 0.0, z: 0.0})</code>.</p>

<h2>xAxis</h2>
<p><code>static get xAxis()</code></p>
<dl>

  <dt>return</dt>
  <dd><code>XcGm3dVector</code> vector.</dd>

</dl>
<p>Return a new XcGm3dVector({x: 1.0, y: 0.0, z: 0.0})</p>

<h2>yAxis</h2>
<p><code>static get yAxis()</code></p>
<dl>

  <dt>return</dt>
  <dd><code>XcGm3dVector</code> vector.</dd>

</dl>
<p>Return a new XcGm3dVector({x: 0.0, y: 1.0, z: 0.0})</p>

<h2>zAxis</h2>
<p><code>static get zAxis()</code></p>
<dl>

  <dt>return</dt>
  <dd><code>XcGm3dVector</code> vector.</dd>

</dl>
<p>Return a new XcGm3dVector({x: 0.0, y: 0.0, z: 1.0})</p>

<h2>fromArray</h2>
<p><code>static fromArray({array})</code></p>
<dl>

  <dt>array</dt>
  <dd>Array in the <code>[x, y, z]</code> form.</dd>


  <dt>return</dt>
  <dd>XcGm#DVector object</dd>

</dl>
<p>Constructs a <code>XcGm3dVector</code> object from an array.</p>

<h2>fromJSON</h2>
<p><code>static fromJSON({json})</code></p>
<dl>

  <dt>json</dt>
  <dd>json object in the <code>{x, y, z}</code> form.</dd>


  <dt>return</dt>
  <dd>XcGm3dVector object</dd>

</dl>
<p>Constructs a <code>XcGm3dVector</code> object from a json object.</p>

<h2>fromThreeVector3</h2>
<p><code>static fromThreeVector3({threeVector3})</code></p>
<dl>

  <dt>threeVector3</dt>
  <dd>Three.js Vector3 object.</dd>


  <dt>return</dt>
  <dd>XcGm3dVector object</dd>

</dl>
<p>Constructs a <code>XcGm3dVector</code> object from a Three.js Vector3 object.</p>

<h2>toString</h2>
<p><code>toString()</code></p>
<dl>

  <dt>return</dt>
  <dd>String representation of the object.</dd>

</dl>

<h2>toArray</h2>
<p><code>toArray()</code></p>
<dl>

  <dt>return</dt>
  <dd>Array representation of the object.</dd>

</dl>

<h2>toJSON</h2>
<p><code>toJSON()</code></p>
<dl>

  <dt>return</dt>
  <dd>Json representation of the object.</dd>

</dl>

<h2>clone</h2>
<p><code>clone()</code></p>
<dl>

  <dt>return</dt>
  <dd><code>XcGm3dVector</code> object which is cloned from the object.</dd>

</dl>

<h2>copy</h2>
<p><code>copy({vector})</code></p>
<dl>

  <dt>vector</dt>
  <dd><code>XcGm3dVector</code> object.</dd>

</dl>
<p>Set the object value from another <code>XcGm3dVector</code> object.</p>

<h2>add</h2>
<p><code>static add({vector1, vector2})</code></p>
<dl>

  <dt>vector1</dt>
  <dd><code>XcGm3dVector</code> object.</dd>


  <dt>vector2</dt>
  <dd><code>XcGm3dVector</code> object.</dd>


  <dt>return</dt>
  <dd><code>XcGm3dVector</code> object.</dd>

</dl>
<p>Get a <code>XcGm3dVector</code> object representing <code>vector1</code> + <code>vector2</code>.</p>

<h2>subtract</h2>
<p><code>static subtract({vector1, vector2})</code></p>
<dl>

  <dt>vector1</dt>
  <dd><code>XcGm3dVector</code> object.</dd>


  <dt>vector2</dt>
  <dd><code>XcGm3dVector</code> object.</dd>


  <dt>return</dt>
  <dd><code>XcGm3dVector</code> object.</dd>

</dl>
<p>Get a <code>XcGm3dVector</code> object representing <code>vector1</code> - <code>vector2</code>.</p>

<h2>multiply</h2>
<p><code>static multiply({vector, scale})</code></p>
<dl>

  <dt>vector</dt>
  <dd><code>XcGm3dVector</code> object.</dd>


  <dt>scale</dt>
  <dd>A floating representing scaling factor.</dd>


  <dt>return</dt>
  <dd><code>XcGm3dVector</code> object.</dd>

</dl>
<p>Get a <code>XcGm3dVector</code> object representing <code>vector * scale</code>.</p>

<h2>divide</h2>
<p><code>static divide({vector, scale})</code></p>
<dl>

  <dt>vector</dt>
  <dd><code>XcGm3dVector</code> object.</dd>


  <dt>scale</dt>
  <dd>A floating representing scaling factor.</dd>


  <dt>return</dt>
  <dd><code>XcGm3dVector</code> object.</dd>

</dl>
<p>Get a <code>XcGm3dVector</code> object representing <code>vector / scale</code>.</p>

<h2>add</h2>
<p><code>add({vector})</code></p>
<dl>

  <dt>vector</dt>
  <dd><code>XcGm3dVector</code> object.</dd>

</dl>
<p>Add the object to the given vector.</p>

<h2>subtract</h2>
<p><code>subtract({vector})</code></p>
<dl>

  <dt>vector</dt>
  <dd><code>XcGm3dVector</code> object.</dd>

</dl>
<p>Subtract the object to the given vector.</p>

<h2>multiply</h2>
<p><code>multiply({scale})</code></p>
<dl>

  <dt>scale</dt>
  <dd>A floating representing scaling factor.</dd>

</dl>
<p>Multiply the object to the given scaling factor.</p>

<h2>divide</h2>
<p><code>divide({scale})</code></p>
<dl>

  <dt>scale</dt>
  <dd>A floating representing scaling factor.</dd>

</dl>
<p>Divide the object to the given scaling factor.</p>

<h2>negate</h2>
<p><code>negate()</code></p>
<p>Negate the object.</p>

<h2>negation</h2>
<p><code>negation()</code></p>
<dl>

  <dt>return</dt>
  <dd><code>XcGm3dVector</code> object.</dd>

</dl>
<p>Get the negation of the object.</p>

<h2>lengthSquared</h2>
<p><code>lengthSquared()</code></p>
<dl>

  <dt>return</dt>
  <dd>A floating number representing the length squared.</dd>

</dl>

<h2>dotProduct</h2>
<p><code>dotProduct({vector})</code></p>
<dl>

  <dt>vector</dt>
  <dd><code>XcGm3dVector</code> object.</dd>


  <dt>return</dt>
  <dd>A floating number representing dot product between this object and another vector.</dd>

</dl>

<h2>set</h2>
<p><code>set({x, y, z})</code></p>
<dl>

  <dt>x</dt>
  <dd>A floating number representing X coordinate.</dd>


  <dt>y</dt>
  <dd>A floating number representing Y coordinate.</dd>


  <dt>z</dt>
  <dd>A floating number representing Z coordinate.</dd>

</dl>
<p>Set the object value with the provided values.</p>

<h2>setToProduct</h2>
<p><code>setToProduct({matrix, vector})</code></p>
<dl>

  <dt>matrix</dt>
  <dd><code>XcGm3dMatrix</code> object.</dd>


  <dt>vector</dt>
  <dd><code>XcGm3dVector</code> object.</dd>

</dl>
<p>Set the object value to the product of the provided matrix and vector.</p>

<h2>transformBy</h2>
<p><code>transformBy({matrix})</code></p>
<dl>

  <dt>matrix</dt>
  <dd><code>XcGm3dMatrix</code> object</dd>

</dl>
<p>Transform the object with the provided matrix.</p>

<h2>perpendicularVector</h2>
<p><code>get perpendicularVector()</code></p>
<dl>

  <dt>return</dt>
  <dd><code>XcGm3dVector</code> object.</dd>

</dl>
<p>Calculate a perpendicular vector of the vector.</p>

<h2>angleTo</h2>
<p><code>angleTo({vector})</code></p>
<dl>

  <dt>vector</dt>
  <dd><code>XcGm3dVector</code> object.</dd>


  <dt>return</dt>
  <dd>A floating number representing the angle to the provided vector.</dd>

</dl>

<h2>rotationAngleTo</h2>
<p><code>rotationAngleTo({vector, axis})</code></p>
<dl>

  <dt>vector</dt>
  <dd><code>XcGm3dVector</code> object.</dd>


  <dt>axis</dt>
  <dd><code>XcGm3dAxis</code> object.</dd>


  <dt>return</dt>
  <dd>A floating number representing the angle to the provided vector.</dd>

</dl>

<h2>normal</h2>
<p><code>get normal()</code></p>
<dl>

  <dt>return</dt>
  <dd><code>XcGm3dVector</code> object representing the normal vector of the object.</dd>

</dl>

<h2>normalize</h2>
<p><code>normalize()</code></p>
<p>Normalize the object.</p>

<h2>length</h2>
<p><code>get length()</code></p>
<dl>

  <dt>return</dt>
  <dd>A floating number representing the length of the object.</dd>

</dl>

<h2>isUnitLength</h2>
<p><code>isUnitLength()</code></p>
<dl>

  <dt>return</dt>
  <dd>Boolean value to indicate if the object is unit length.</dd>

</dl>

<h2>isZeroLength</h2>
<p><code>isZeroLength()</code></p>
<dl>

  <dt>return</dt>
  <dd>Boolean value to indicate if the object is zero length.</dd>

</dl>

<h2>isParallelTo</h2>
<p><code>isParallelTo({vector})</code></p>
<dl>

  <dt>vector</dt>
  <dd><code>XcGm3dVector</code> object to check.</dd>


  <dt>return</dt>
  <dd>Boolean value to indicate if the object is parallel to the given vector.</dd>

</dl>

<h2>isCodirectionalTo</h2>
<p><code>isCodirectionalTo({vector})</code></p>
<dl>

  <dt>vector</dt>
  <dd><code>XcGm3dVector</code> object to check.</dd>


  <dt>return</dt>
  <dd>Boolean value to indicate if the object is co-directional to the given vector.</dd>

</dl>

<h2>isPerpendicularTo</h2>
<p><code>isPerpendicularTo({vector})</code></p>
<dl>

  <dt>vector</dt>
  <dd><code>XcGm3dVector</code> object to check.</dd>


  <dt>return</dt>
  <dd>Boolean value to indicate if the object is perpendicular to the given vector.</dd>

</dl>

<h2>isEqualTo</h2>
<p><code>isEqualTo({vector})</code></p>
<dl>

  <dt>vector</dt>
  <dd><code>XcGm3dVector</code> object to check.</dd>


  <dt>return</dt>
  <dd>Boolean value to indicate if the object is equal to the given vector.</dd>

</dl>

<h2>crossProduct</h2>
<p><code>crossProduct({vector})</code></p>
<dl>

  <dt>vector</dt>
  <dd><code>XcGm3dVector</code> object.</dd>


  <dt>return</dt>
  <dd>A <code>XcGm3dVector</code> object representing <code>this X vector</code>.</dd>

</dl>

<h2>toThreeVector3</h2>
<p><code>toThreeVector3()</code></p>
<dl>

  <dt>return</dt>
  <dd>A Three.js vector3 representation.</dd>

</dl>

<h1>XcGmAssembly</h1>
<p><code>class XcGmAssembly extends XcGmPart</code></p>

<h2>constructor</h2>
<p><code>constructor()</code></p>

<h2>parts</h2>
<p><code>get parts()</code></p>

<h2>create</h2>
<p><code>static create()</code></p>

<h2>instances</h2>
<p><code>instances()</code></p>
<p>Return XcGmInstance objects</p>

<h2>partsAndTransfs</h2>
<p><code>partsAndTransfs()</code></p>

<h2>transformBy</h2>
<p><code>transformBy({matrix})</code></p>

<h2>makeLevelAssembly</h2>
<p><code>makeLevelAssembly()</code></p>

<h1>XcGm3dAxis</h1>
<p><code>class XcGm3dAxis</code></p>

<h2>position</h2>
<p><code>position</code></p>
<p>XcGm3dPosition object</p>

<h2>direction</h2>
<p><code>direction</code></p>
<p>XcGm3dVector object</p>

<h2>constructor</h2>
<pre><code>constructor({
                position = new XcGm3dPosition(),
                direction = new XcGm3dVector({x: 0, y: 0, z: 1})
              } = {})
</code></pre>

<h2>toJSON</h2>
<p><code>toJSON()</code></p>

<h2>fromJSON</h2>
<p><code>fromJSON({json})</code></p>

<h1>XcGmBlendSurface</h1>
<p><code>class XcGmBlendSurface extends XcGmSurface</code></p>

<h2>constructor</h2>
<p><code>constructor() { super(); }</code></p>

<h1>XcGmBody</h1>
<p><code>class XcGmBody extends XcGmPart</code></p>

<h2>BODY_TYPE</h2>
<pre><code>  static BODY_TYPE = {
    MINIMUM: 5603,
    ACORN: 5606,
    WIRE: 5604,
    SHEET: 5602,
    SOLID: 5601,
    GENERAL: 5605,
    UNSPECIFIED: 5607,
    EMPTY: 5608,
    COMPOUND: 5609
  };
</code></pre>

<h2>BooleanFunction</h2>
<pre><code>  static BooleanFunction = {
    Intersection: 15901, /* intersect */
    Subtraction: 15902, /* subtract */
    Union: 15903 /* unite */
  };
</code></pre>

<h2>constructor</h2>
<p><code>constructor()</code></p>

<h2>faces</h2>
<p><code>get faces()</code></p>

<h2>edges</h2>
<p><code>get edges()</code></p>
<p>Return XcGmEdge</p>

<h2>vertices</h2>
<p><code>get vertices()</code></p>
<p>Return XcGmVertex</p>

<h2>type</h2>
<p><code>get type()</code></p>
<p>Return XcGmBody.BODY_TYPE</p>

<h2>createSolidBlock</h2>
<p><code>static createSolidBlock({x, y, z, coordinateSystem = new XcGmCoordinateSystem()})</code></p>
<p>Return XcGmBody</p>

<h2>createSolidCone</h2>
<p><code>static createSolidCone({radius, height, semiAngle, coordinateSystem = new XcGmCoordinateSystem()})</code></p>

<h2>createSolidCylinder</h2>
<p><code>static createSolidCylinder({radius, height, coordinateSystem = new XcGmCoordinateSystem()})</code></p>

<h2>createSolidPrism</h2>
<p><code>static createSolidPrism({radius, height, sides, coordinateSystem = new XcGmCoordinateSystem()})</code></p>

<h2>createSolidSphere</h2>
<p><code>static createSolidSphere({radius, coordinateSystem = new XcGmCoordinateSystem()})</code></p>

<h2>createSolidTorus</h2>
<p><code>static createSolidTorus({majorRadius, minorRadius, coordinateSystem = new XcGmCoordinateSystem()})</code></p>

<h2>createSheetCircle</h2>
<p><code>static createSheetCircle({radius, coordinateSystem = new XcGmCoordinateSystem()})</code></p>

<h2>extrudeAlong</h2>
<p><code>extrudeAlong({direction, options})</code></p>
<p>Example</p>
<pre><code>        let myBody = ....;
        let direction = new XcGm3dVector({x: 0, y: 0, z: 1});
        let extrudedBody = myBody.extrudeAlong({
          direction: direction,
          options: {
            distance: 1
          }
        });
</code></pre>

<h2>spin</h2>
<p><code>spin({axis, angle})</code></p>
<dl>
  axis XcGm3dAxis object</dd>
</dl>
<p>Example:</p>
<pre><code>    let axis = ...;
    this.#profileBody.spin({axis, angle: Math.PI});
</code></pre>

<h2>transformBy</h2>
<p><code>transformBy({matrix})</code></p>

<h2>boolean</h2>
<p><code>boolean({tools, func})</code></p>
<dl>
  tools: XcGmBody objects</dd>
  func XcGmBody.BooleanFunction</dd>
</dl>
<p>Return result bodies</p>

<h2>fixBlends</h2>
<p><code>fixBlends()</code></p>

<h2>hollowFaces</h2>
<p><code>hollowFaces({faces, offset})</code></p>
<dl>
  faces: XcGmFace</dd>
  offset: A floating point number</dd>
</dl>

<h2>imprintCurve</h2>
<p><code>imprintCurve({curve, bounds})</code></p>

<h2>findVertexByPosition</h2>
<p><code>findVertexByPosition({position})</code></p>
<p>Return XcGmVertex</p>

<h2>findEdgeByPositions</h2>
<p><code>findEdgeByPositions({positions})</code></p>

<h2>findEdgeByVertices</h2>
<p><code>findEdgeByVertices({vertex1, vertex2})</code></p>

<h2>findFaceByPositions</h2>
<p><code>findFaceByPositions({positions})</code></p>

<h2>findFaceByEdges</h2>
<p><code>findFaceByEdges({edges})</code></p>

<h2>findFaceByVertices</h2>
<p><code>findFaceByVertices({vertices})</code></p>

<h2>findVertexWithFilter</h2>
<p><code>findVertexWithFilter({callback})</code></p>

<h2>findEdgeWithFilter</h2>
<p><code>findEdgeWithFilter({callback})</code></p>

<h2>findFaceWithFilter</h2>
<p><code>findFaceWithFilter({callback})</code></p>

<h1>XcGm3dBox</h1>
<p><code>class XcGm3dBox</code></p>

<h2>constructor</h2>
<p><code>constructor({minimumX, minimumY, minimumZ, maximumX, maximumY, maximumZ})</code></p>

<h2>fromJSON</h2>
<p><code>static fromJSON({json})</code></p>

<h2>toJSON</h2>
<p><code>toJSON()</code></p>

<h1>XcGmBSurface</h1>
<p><code>class XcGmBSurface extends XcGmSurface</code></p>

<h2>constructor</h2>
<p><code>constructor()</code></p>

<h2>XcGmCone</h2>
<p><code>class XcGmCone extends XcGmSurface</code></p>

<h2>constructor</h2>
<p><code>constructor()</code></p>

<h1>XcGmContext</h1>
<p><code>class XcGmContext</code></p>

<h2>gTol</h2>
<p><code>static gTol = new XcGmPrecision();</code></p>

<h2>constructor</h2>
<p><code>constructor()</code></p>

<h1>XcGmCoordinateSystem</h1>
<p><code>class XcGmCoordinateSystem</code></p>

<h2>origin</h2>
<p><code>origin</code></p>
<p>XcGm3dPosition</p>

<h2>zAxis</h2>
<p><code>zAxis</code></p>
<p>XcGm3dVector</p>

<h2>xAxis</h2>
<p><code>xAxis</code></p>
<p>XcGm3dVector</p>

<h2>constructor</h2>
<p><code>constructor({ origin = new XcGm3dPosition(), zAxis = new XcGm3dVector({x: 0, y: 0, z: 1}), xAxis = new
  XcGm3dVector({x: 1, y: 0, z: 0}) } = {})</code></p>

<h2>fromMatrix</h2>
<p><code>static fromMatrix({matrix})</code></p>

<h2>toMatrix</h2>
<p><code>toMatrix()</code></p>

<h2>transformToCoordinateSystem</h2>
<p><code>transformToCoordinateSystem({coordinateSystem})</code></p>

<h2>fromJSON</h2>
<p><code>static fromJSON({json})</code></p>

<h2>toJSON</h2>
<p><code>toJSON()</code></p>

<h2>XcGmCylinder</h2>
<p><code>class XcGmCylinder extends XcGmSurface</code></p>

<h2>constructor</h2>
<p><code>constructor()</code></p>

<h2>XcGmEdge</h2>
<p><code>class XcGmEdge extends XcGmTopology</code></p>

<h2>body</h2>
<p><code>get body()</code></p>

<h2>curve</h2>
<p><code>get curve()</code></p>

<h2>faces</h2>
<p><code>get faces()</code></p>
<p>Return XcGmFace array</p>

<h2>vertices</h2>
<p><code>get vertices()</code></p>
<p>Return {vertex1, vertex2} where vertex1 and vertex2 are XcGmVertex</p>

<h2>makeFacesFrom</h2>
<p><code>static makeFacesFrom({edges, senses, sharedLoop})</code></p>
<dl>
  Return XcGmFace array</dd>
</dl>
<p>Example</p>
<pre><code>      let {wire, newEdges} = XcGm3dCurve.makeWireBodyFromCurves({curves, bounds});
      let faces = XcGmEdge.makeFacesFrom({edges: [newEdges[0].edge], senses: [true], sharedLoop: [-1]});
</code></pre>

<h2>setBlendConstantFor</h2>
<p><code>static setBlendConstantFor({edges, radius})</code></p>
<dl>
  Return blend edges.</dd>
</dl>
<p>Example</p>
<pre><code>    let edges = ...;
    XcGmEdge.setBlendConstantFor({edges, radius: 0.01});
    myBody.fixBlends();
</code></pre>

<h2>findInterval</h2>
<p><code>findInterval()</code></p>
<dl>
  Return XcGmInterval</dd>
</dl>

<h2>containsVector</h2>
<p><code>containsVector({vector})</code></p>
<dl>
  Return XcGmTopology</dd>
</dl>
<p>Example</p>
<pre><code>          let topol = edge.containsVector({vector});
          if (topol) {
            // The edge contains the vector
          }
</code></pre>

<h2>findVertexByPosition</h2>
<p><code>findVertexByPosition({position})</code></p>
<dl>
  Return null or XcGmVertex object found.</dd>
</dl>

<h2>findVertexWithFilter</h2>
<p><code>findVertexWithFilter({callback})</code></p>
<dl>
  callback filter function in the form of <code>callback(vertex[, index[, array]</code>])</dd>
  Return filtered array, which could be empty array.</dd>
</dl>

<h1>XcGmEntity</h1>
<p><code>class XcGmEntity</code></p>

<h2>tag</h2>
<p><code>tag</code></p>
<p>A unique handle number</p>

<h2>constructor</h2>
<p><code>constructor()</code></p>

<h2>getObjFromTag</h2>
<p><code>static getObjFromTag({entityTag})</code></p>

<h2>PKDelete</h2>
<p><code>static PKDelete({entity})</code></p>

<h2>toJSON</h2>
<p><code>toJSON()</code></p>

<h2>clone</h2>
<p><code>clone()</code></p>

<h1>XcGmFace</h1>
<p><code>class XcGmFace extends XcGmTopology</code></p>

<h2>constructor</h2>
<p><code>constructor()</code></p>

<h2>surf</h2>
<p><code>get surf()</code></p>
<p>Return XcGmSurface</p>

<h2>UVBox</h2>
<p><code>get UVBox()</code></p>
<dl>
  Return XcGmUVBox</dd>
</dl>

<h2>body</h2>
<p><code>get body()</code></p>
<dl>
  Return XcGmBody</dd>
</dl>

<h2>edges</h2>
<p><code>get edges()</code></p>
<dl>
  Return XcGmEdge array</dd>
</dl>

<h2>vertices</h2>
<p><code>get vertices()</code></p>
<dl>
  Return XcGmVertex array</dd>
</dl>

<h2>delete</h2>
<p><code>static delete({faces})</code></p>
<dl>
  faces XcGmFace array</dd>
</dl>
<p>Delete faces from a body</p>

<h2>transform</h2>
<p><code>static transform({facesAndMatrices, tolerance})</code></p>
<dl>
  facesAndMatrices Array of XcGmFace and XcGm3dMatrix</dd>
  tolerance floating number</dd>
</dl>
<p>Example</p>
<pre><code>        let face = ....;
        let matrix = ....;
        XcGmFace.transform({
          facesAndMatrices: [{face, matrix}],
          tolerance: 1e-5
        });
</code></pre>

<h2>surfAndOrientation</h2>
<p><code>surfAndOrientation()</code></p>
<dl>
  Return {surf, orientation}</dd>
</dl>
<p>Example</p>
<pre><code>      let face = ...;
      let {surf, orientation} = face.surfAndOrientation();
      if (surf instanceof XcGmPlane) {
        let coordinateSystem = surf.coordinateSystem;
        let faceDir = coordinateSystem.zAxisDirection;
        if (!orientation) {
          faceDir.negate();
        }
      }
</code></pre>

<h2>attachSurfFitting</h2>
<p><code>attachSurfFitting({localCheck})</code></p>
<dl>
  Return localCheckResult</dd>
</dl>
<p>Example</p>
<pre><code>      let {wire, newEdges} = XcGm3dCurve.makeWireBodyFromCurves({curves, bounds});
      let faces = XcGmEdge.makeFacesFrom({edges: [newEdges[0].edge], senses: [true], sharedLoop: [-1]});
      XcSysAssert({
        assertion: faces.length === 1,
        message: `Cannot generate sheet body. Single loop supported only`
      });
      let face = faces[0];
      let localCheckStatus = face.attachSurfFitting({localCheck: true});
      let faceBody = face.body;
</code></pre>

<h2>findVertexByPosition</h2>
<p><code>findVertexByPosition({position})</code></p>
<dl>
  position XcGm3dPosition</dd>
  Return XcGmVertex or null when not found</dd>
</dl>

<h2>findEdgeByVertex</h2>
<p><code>findEdgeByVertex(vertex)</code></p>
<dl>
  vertex XcGmVertex</dd>
  Return XcGmEdge array</dd>
</dl>

<h2>findEdgeByTwoVertices</h2>
<p><code>findEdgeByTwoVertices({vertex1, vertex2})</code></p>
<dl>
  vertex1 XcGmVertex</dd>
  vertex2 XcGmVertex</dd>
  Return XcGmEdge or null</dd>
</dl>

<h2>findVertexWithFilter</h2>
<p><code>findVertexWithFilter({callback})</code></p>
<dl>
  callback filter function in the form of <code>callback(vertex[, index[, array]</code>])</dd>
  Return filtered vertex array, which could be empty array.</dd>
</dl>

<h2>findEdgeWithFilter</h2>
<p>`findEdgeWithFilter({callback})``</p>
<dl>
  callback filter function in the form of <code>callback(edge[, index[, array]</code>])</dd>
  Return filtered edge array, which could be empty array.</dd>
</dl>

<h1>XcGmGeometry</h1>
<p><code>class XcGmGeometry extends XcGmEntity</code></p>

<h2>constructor</h2>
<p><code>constructor()</code></p>

<h1>XcGmInstance</h1>
<p><code>class XcGmInstance extends XcGmTopology</code></p>

<h2>constructor</h2>
<p><code>constructor()</code></p>

<h2>assembly</h2>
<p><code>get assembly()</code></p>
<dl>
  Return XcGmAssembly</dd>
</dl>

<h2>transform</h2>
<p><code>get transform()</code></p>
<dl>
  Return XcGm3dMatrix</dd>
</dl>

<h2>part</h2>
<p><code>get part()</code></p>
<dl>
  Return XcGmPart</dd>
</dl>

<h2>create</h2>
<p><code>static create({assembly, part, matrix = null})</code></p>
<dl>
  assembly XcGmAssembly</dd>
  part XcGmPart</dd>
  matrix null or XcGm3dMatrix</dd>
</dl>

<h2>changePart</h2>
<p><code>changePart({part})</code></p>
<dl>
  part XcGmPart</dd>
</dl>

<h2>replaceTransf</h2>
<p><code>replaceTransf({transf})</code></p>
<dl>
  transf XcGmTransf</dd>
</dl>

<h2>transformBy</h2>
<p><code>transformBy({matrix})</code></p>
<dl>
  matrix XcGm3dMatrix</dd>
</dl>

<h1>XcGmInterval</h1>
<p><code>class XcGmInterval</code></p>

<h2>low</h2>
<p><code>low</code></p>

<h2>high</h2>
<p><code>high</code></p>

<h2>constructor</h2>
<p><code>constructor({low, high})</code></p>

<h2>fromJSON</h2>
<p><code>static fromJSON({json})</code></p>

<h2>toJSON</h2>
<p><code>toJSON()</code></p>

<h1>XcGmLoop</h1>
<p><code>class XcGmLoop extends XcGmTopology</code></p>

<h2>constructor</h2>
<p><code>constructor()</code></p>

<h1>XcGmOffset</h1>
<p><code>class XcGmOffset extends XcGmSurface</code></p>

<h2>constructor</h2>
<p><code>constructor()</code></p>

<h1>XcGmPart</h1>
<p><code>class XcGmPart extends XcGmTopology</code></p>

<h2>constructor</h2>
<p><code>constructor()</code></p>

<h2>transmitToData</h2>
<p><code>static transmitToData({parts})</code></p>

<h2>transmitToFile</h2>
<p><code>static transmitToFile({parts, path})</code></p>

<h2>receiveFromData</h2>
<p><code>static receiveFromData({data})</code></p>

<h2>receiveFromFile</h2>
<p><code>static receiveFromFile({fileName})</code></p>

<h2>findEntityByIdent</h2>
<p><code>findEntityByIdent({identifier, cls})</code></p>

<h1>XcGmPK_CIRCLE_sf_t</h1>
<p><code>class XcGmPK_CIRCLE_sf_t</code></p>

<h2>radius</h2>
<p><code>radius</code></p>

<h2>basisSet</h2>
<p><code>basisSet</code></p>
<p>XcGmPK_AXIS2_sf_t</p>

<h2>constructor</h2>
<p><code>constructor({ radius, basisSet = new XcGmPK_AXIS2_sf_t() })</code></p>

<h2>toJSON</h2>
<p><code>toJSON()</code></p>

<h2>fromJSON</h2>
<p><code>static fromJSON({json})</code></p>

<h1>XcGmPK_LINE_sf_t</h1>
<p><code>class XcGmPK_LINE_sf_t</code></p>

<h2>basisSet</h2>
<p><code>basisSet</code></p>
<p>XcGmPK_AXIS1_sf_t</p>

<h2>constructor</h2>
<p><code>constructor(basisSet = new XcGmPK_AXIS1_sf_t())</code></p>

<h2>toJSON</h2>
<p><code>toJSON()</code></p>

<h2>fromJSON</h2>
<p><code>static fromJSON({json})</code></p>

<h1>XcGmPK_POINT_sf_t</h1>
<p><code>class XcGmPK_POINT_sf_t</code></p>

<h2>position</h2>
<p><code>position</code></p>
<p>XcGm3dPosition</p>

<h2>constructor</h2>
<p><code>constructor(position = new XcGm3dPosition())</code></p>

<h2>toJSON</h2>
<p><code>toJSON()</code></p>

<h2>fromJSON</h2>
<p><code>static fromJSON({json})</code></p>

<h1>XcGmPK_AXIS1_sf_t</h1>
<p><code>class XcGmPK_AXIS1_sf_t</code></p>

<h2>location</h2>
<p><code>location</code></p>
<p>XcGm3dPosition</p>

<h2>axis</h2>
<p><code>axis</code></p>
<p>XcGm3dVector</p>

<h2>constructor</h2>
<pre><code>  constructor({
                location = new XcGm3dPosition(),
                axis = new XcGm3dVector({x: 0, y: 0, z: 1})
              } = {})
</code></pre>

<h2>toJSON</h2>
<p><code>toJSON()</code></p>

<h2>fromJSON</h2>
<p><code>static fromJSON({json})</code></p>

<h1>XcGmPK_AXIS2_sf_t</h1>
<p><code>class XcGmPK_AXIS2_sf_t</code></p>

<h2>location</h2>
<p><code>location</code></p>
<p>XcGm3dPosition</p>

<h2>axis</h2>
<p><code>axis</code></p>
<p>XcGm3dVector</p>

<h2>refDirection</h2>
<p><code>refDirection</code></p>
<p>XcGm3dVector</p>

<h2>constructor</h2>
<p><code>constructor({ location = new XcGm3dPosition(), axis = new XcGm3dVector({x: 0, y: 0, z: 1}), refDirection = new
  XcGm3dVector({x: 1, y: 0, z: 0}) } = {})</code></p>

<h2>toJSON</h2>
<p><code>toJSON()</code></p>

<h2>fromJSON</h2>
<p><code>static fromJSON({json})</code></p>

<h1>XcGmPK_INSTANCE_sf_t</h1>
<p><code>class XcGmPK_INSTANCE_sf_t</code></p>

<h2>assembly</h2>
<p><code>assembly</code></p>
<p>XcGmAssembly</p>

<h2>transf</h2>
<p><code>transf</code></p>
<p>XcGmPKTransf</p>

<h2>part</h2>
<p>XcGmPart</p>

<h2>constructor</h2>
<p><code>constructor({ assembly = null, transf = null, part = null } = {})</code></p>
<p><code>part</code></p>

<h2>toJSON</h2>
<p><code>toJSON()</code></p>

<h2>fromJSON</h2>
<p><code>static fromJSON({json})</code></p>

<h1>XcGmPK_PLANE_sf_t</h1>
<p><code>class XcGmPK_PLANE_sf_t</code></p>

<h2>basisSet</h2>
<p><code>basisSet</code></p>
<p>XcGmPK_AXIS2_sf_t</p>

<h2>constructor</h2>
<p><code>constructor(basisSet = new XcGmPK_AXIS2_sf_t())</code></p>

<h2>toJSON</h2>
<p><code>toJSON()</code></p>

<h2>fromJSON</h2>
<p><code>static fromJSON({json})</code></p>

<h1>XcGmPK_SPHERE_sf_t</h1>
<p><code>class XcGmPK_SPHERE_sf_t</code></p>

<h2>radius</h2>
<p><code>radius</code></p>

<h2>basisSet</h2>
<p><code>basisSet</code></p>
<p>XcGmPK_AXIS2_sf_t</p>

<h2>constructor</h2>
<pre><code>  constructor({
                radius,
                basisSet = new XcGmPK_AXIS2_sf_t()
              })
</code></pre>

<h2>toJSON</h2>
<p><code>toJSON()</code></p>

<h2>fromJSON</h2>
<p><code>static fromJSON({json})</code></p>

<h1>XcGmTransf</h1>
<p><code>class XcGmTransf extends XcGmEntity</code></p>

<h2>constructor</h2>
<p><code>constructor()</code></p>

<h2>matrix</h2>
<p><code>get matrix()</code></p>
<p>Return XcGm3dMatrix</p>

<h2>create</h2>
<p><code>static create({transfSF})</code></p>
<dl>
  transfSF XcGmPK_TRANSF_sf_t</dd>
</dl>

<h1>XcGmPK_TRANSF_sf_t</h1>
<p><code>class XcGmPK_TRANSF_sf_t</code></p>

<h2>matrix</h2>
<p><code>matrix</code></p>
<p>XcGm3dMatrix</p>

<h2>toJSON</h2>
<p><code>toJSON()</code></p>

<h2>fromJSON</h2>
<p><code>static fromJSON({json})</code></p>

<h1>XcGmPlane</h1>
<p><code>class XcGmPlane extends XcGmSurface</code></p>

<h2>constructor</h2>
<p><code>constructor()</code></p>

<h2>coordinateSystem</h2>
<p><code>get coordinateSystem()</code></p>
<p>Return XcGmCoordinateSystem</p>

<h2>create</h2>
<p><code>static create({coordinateSystem})</code></p>

<h1>XcGmPrecision</h1>
<p><code>class XcGmPrecision</code></p>

<h2>linearPrecision</h2>
<p><code>linearPrecision</code></p>

<h2>anglePrecision</h2>
<p><code>anglePrecision</code></p>

<h2>constructor</h2>
<p><code>constructor({linearPrecision = 1.0e-8, anglePrecision = 1.0e-11} = {})</code></p>

<h1>XcGmSphere</h1>
<p><code>class XcGmSphere extends XcGmSurface</code></p>

<h2>constructor</h2>
<p><code>constructor()</code></p>

<h2>radius</h2>
<p><code>get radius()</code></p>

<h2>coordinateSystem</h2>
<p><code>get coordinateSystem()</code></p>
<p>Return XcGmCoordinateSystem</p>

<h2>create</h2>
<p><code>static create({radius, coordinateSystem})</code></p>

<h1>XcGmSpun</h1>
<p><code>class XcGmSpun extends XcGmSurface</code></p>

<h2>constructor</h2>
<p><code>constructor()</code></p>

<h1>XcGmSurface</h1>
<p><code>class XcGmSurface extends XcGmGeometry</code></p>

<h2>constructor</h2>
<p><code>constructor()</code></p>

<h2>evaluate</h2>
<p><code>evaluate({uv})</code></p>
<dl>
  uv XcGmUV</dd>
  Return XcGm3dPosition</dd>
</dl>

<h1>XcGmSwept</h1>
<p><code>class XcGmSwept extends XcGmSurface</code></p>

<h2>constructor</h2>
<p><code>constructor()</code></p>

<h1>XcGmTorus</h1>
<p><code>class XcGmTorus extends XcGmSurface</code></p>

<h2>constructor</h2>
<p><code>constructor()</code></p>

<h1>XcGmTopology</h1>
<p><code>class XcGmTopology extends XcGmEntity</code></p>

<h2>constructor</h2>
<p><code>constructor()</code></p>

<h2>box</h2>
<p><code>get box()</code></p>
<p>Return XcGm3dBox</p>

<h2>evalMassPropsFor</h2>
<p><code>static evalMassPropsFor({topols, accuracy})</code></p>
<dl>
  topols XcGmTopology object array</dd>
  accuracy Computational accuracy</dd>
  return {amount, mass, cog, mofi, periphery}</dd>
</dl>
<p>Example</p>
<pre><code>      let {cog} = XcGmTopology.evalMassPropsFor({topols: [myTopol], accuracy: 1});
</code></pre>

<h2>render</h2>
<p><code>render()</code></p>
<dl>
  return {allFaceRenderingData, allEdgeRenderingData, allVertexRenderingData}</dd>
</dl>

<h1>XcGmUV</h1>

<h2>u</h2>
<p><code>u</code></p>

<h2>v</h2>
<p><code>v</code></p>

<h2>constructor</h2>
<p><code>constructor({u, v})</code></p>

<h2>toJSON</h2>
<p><code>toJSON()</code></p>

<h2>fromJSON</h2>
<p><code>static fromJSON({json})</code></p>

<h1>XcGmUVBox</h1>
<p><code>class XcGmUVBox</code></p>

<h2>param</h2>
<p><code>param</code></p>

<h2>constructor</h2>
<p><code>constructor({lowU, lowV, highU, highV})</code></p>

<h2>toJSON</h2>
<p><code>toJSON()</code></p>

<h2>fromJSON</h2>
<p><code>static fromJSON({json})</code></p>

<h1>XcGmVertex</h1>
<p><code>class XcGmVertex extends XcGmTopology</code></p>

<h2>constructor</h2>
<p><code>constructor()</code></p>

<h2>point</h2>
<p><code>get point()</code></p>
<p>Return XcGmPoint</p>

<h2>body</h2>
<p><code>get body()</code></p>
<p>Return XcGmBody</p>

<h2>faces</h2>
<p><code>get faces()</code></p>
<p>Return XcGmFace array</p>

<h1>XcGmQuaternion</h1>
<p><code>class XcGmQuaternion</code></p>
<dl>
  Construct a quaternion.</dd>
  </dd>
  @param {*} the components of the quaternion to construct. The default is the unit.<br>
  */
  </dd>
</dl>

<h2>constructor</h2>
<p><code>constructor({w = 1, x = 0, y = 0, z = 0} = {})</code></p>

<h2>fromRotationMatrix</h2>
<p><code>static fromRotationMatrix({matrix})</code></p>
<p>*matrix a rotation matrix<br>
  Convert a rotation matrix to a unit quaternion<br>
  Assuming the input matrix is a pure rotation matrix:<br>
  any perspective factor or translation vector is ignored</p>

<h2>conjugate</h2>
<p><code>conjugate()</code><br>
  The inverse quaternion for a unit quaternion</p>

<h2>multiply</h2>
<p><code>multiply({qRight})</code></p>
<p>*qRight the quaternion on the right<br>
  Hamliton product. The multiplication order puts the current quaternion on the left</p>

<h2>normalize</h2>
<p><code>normalize()</code> {</p>
<p>Normalize the current quaternion. If the normal is zero within tolerance, no-op.</p>

<h2>normal</h2>
<p><code>normal()</code></p>
<p>A normalized quaternion from the current. The current is not changed</p>

<h2>lengthSquared</h2>
<p><code>lengthSquared()</code></p>
<p>The Squared length</p>

<h2>pow</h2>
<p><code>pow({exponent})</code></p>
<p>*exponent the exponent</p>
<p>The power function, assuming unit quaternions</p>

<h2>lerpTo</h2>
<p><code>lerpTo({target, exponent})</code></p>
<p>*target the target unit quaternion for linear interpolation from the current<br>
  *exponent the interpolation parameter. If the parameter is 0, the interpolation result is the current quaterion.<br>
  If the parameter is 1, the result is the target quaternion</p>
<p>linear interpolation of two rotation quaterions:

  q0 to q1, with parameter t: q0 * (q0’ * q1)^t, q0’ being the conjugate: q0’ = 1/q0 for unit quaternions;</p>
  t=0, the result is q0;
  t=1, the result is q1;
  otherwise, the result is a linear interpolation

<h2>toRotationMatrix</h2>
<p><code>toRotationMatrix()</code></p>

</body>
</html>
