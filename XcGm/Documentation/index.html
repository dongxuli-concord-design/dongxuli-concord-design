<html>
<meta charset="UTF-8">
<head>
  <title>Documentation</title>
  <link href="../bootstrap.css" rel="stylesheet" type="text/css">
  <meta content="width=device-width, initial-scale=1.0, user-scalable=no" name="viewport">
</head>
<body style="margin: 10px;">

<h1>Introduction</h1>
Geometric modeling library

<h2>XcGmAssert</h2>
<code>function XcGmAssert({assertion, message = 'Unknown'})</code>

<h2>XcGm2dPosition</h2>
<code>class XcGm2dPosition</code>

Represents a 2D position.

<h3>constructor</h3>
<code>constructor({x = 0.0, y = 0.0} = {})</code>

<dl>
  <dt>x</dt>
  <dd>A floating number representing X coordinate.</dd>
  <dt>y</dt>
  <dd>A floating number representing Y coordinate.</dd>
</dl>

<h3>fromArray</h3>
<code>static fromArray({array})</code>

<dl>
  <dt>array</dt>
  <dd>Array in the <code>[x, y]</code> form.</dd>
  <dt>return</dt>
  <dd><code>XcGm2dPosition</code> object</dd>
</dl>
Constructs a XcGm2dPosition object from an array.

<h3>fromJSON</h3>
<code>static fromJSON({json})</code>

<dl>
  <dt>json</dt>
  <dd>json object in the <code>{x, y}</code> form.</dd>
  <dt>return</dt>
  <dd><code>XcGm2dPosition</code> object</dd>
</dl>
Constructs a <code>XcGm2dPosition</code> object from a json object.

<h3>fromThreeVector2</h3>
<code>static fromThreeVector2({threeVector2})</code>

<dl>
  <dt>threeVector2</dt>
  <dd>Three.js Vector2 object.</dd>
  <dt>return</dt>
  <dd>XcGm2dPosition object</dd>
</dl>
Constructs a <code>XcGm2dPosition</code> object from a Three.js Vector2 object.

<h3>toThreeVector2</h3>
<code>toThreeVector2</code>

<dl>
  <dt>return</dt>
  <dd>Three.js Vector2 object</dd>
</dl>
Constructs a Three.js Vector2 object from this <code>XcGm2dPosition</code> object.

<h3>toString</h3>
<code>toString()</code>

<dl>
  <dt>return</dt>
  <dd>String representation of the object.</dd>
</dl>

<h3>toArray</h3>
<code>toArray()</code>

<dl>
  <dt>return</dt>
  <dd>Array representation of the object.</dd>
</dl>

<h3>toJSON</h3>
<code>toJSON()</code>

<dl>
  <dt>return</dt>
  <dd>Json representation of the object.</dd>
</dl>

<h3>clone</h3>
<code>clone()</code>

<dl>
  <dt>return</dt>
  <dd>XcGm2dPosition which is cloned from the object.</dd>
</dl>

<h3>copy</h3>
<code>copy({position})</code>

<dl>
  <dt>position</dt>
  <dd>Another XcGm2dPosition object.</dd>
</dl>
Set the object value from another <code>XcGm2dPosition</code> object.

<h2>XcGm2dVector</h2>
<code>class XcGm2dVector</code>

Represents a 2D vector.

<h3>constructor</h3>
<code>constructor({x = 0.0, y = 0.0} = {})</code>

<dl>
  <dt>x</dt>
  <dd>A floating number representing X coordinate.</dd>
  <dt>y</dt>
  <dd>A floating number representing Y coordinate.</dd>
</dl>

<h3>fromArray</h3>
<code>static fromArray({array})</code>

<dl>
  <dt>array</dt>
  <dd>Array in the <code>[x, y]</code> form.</dd>
  <dt>return</dt>
  <dd>XcGm2dVector object</dd>
</dl>
Constructs a <code>XcGm2dVector</code> object from an array.

<h3>fromJSON</h3>
<code>static fromJSON({json})</code>

<dl>
  <dt>json</dt>
  <dd>json object in the <code>{x, y}</code> form.</dd>
  <dt>return</dt>
  <dd>XcGm2dVector object</dd>
</dl>
Constructs a <code>XcGm2dVector</code> object from a json object.

<h3>fromThreeVector2</h3>
<code>static fromThreeVector2({threeVector2})</code>

<dl>
  <dt>threeVector2</dt>
  <dd>Three.js Vector2 object.</dd>
  <dt>return</dt>
  <dd>XcGm2dVector object</dd>
</dl>
Constructs a <code>XcGm2dVector</code> object from a Three.js Vector2 object.

<h3>toThreeVector2</h3>
<code>toThreeVector2</code>

<dl>
  <dt>return</dt>
  <dd>Three.js Vector2 object</dd>
</dl>
Constructs a Three.js Vector2 object from this <code>XcGm2dVector</code> object.

<h3>toString</h3>
<code>toString()</code>

<dl>
  <dt>return</dt>
  <dd>String representation of the object.</dd>
</dl>

<h3>toArray</h3>
<code>toArray()</code>

<dl>
  <dt>return</dt>
  <dd>Array representation of the object.</dd>
</dl>

<h3>toJSON</h3>
<code>toJSON()</code>

<dl>
  <dt>return</dt>
  <dd>Json representation of the object.</dd>
</dl>

<h3>clone</h3>
<code>clone()</code>

<dl>
  <dt>return</dt>
  <dd><code>XcGm2dVector</code> object which is cloned from the object.</dd>
</dl>

<h3>copy</h3>
<code>copy({vector})</code>

<dl>
  <dt>vector</dt>
  <dd><code>XcGm2dVector</code> object.</dd>
</dl>
Set the object value from another <code>XcGm2dVector</code> object.

<h2>XcGm3dBCurve</h2>
<code>class XcGm3dCurve extends XcGmGeometry</code>

Represents 3D BCurve.

<h2>XcGm2dAxis</h2>
<code>class XcGm2dAxis</code>

<h3>position</h3>
<code>position</code>

XcGm2dPosition object

<h3>direction</h3>
<code>direction</code>

XcGm2dVector object

<h3>constructor</h3>
<pre><code>constructor({
                position = new XcGm2dPosition(),
                direction = new XcGm2dVector({x: 0, y: 0, z: 1})
              } = {})
</code></pre>

<h3>toJSON</h3>
<code>toJSON()</code>

<h3>fromJSON</h3>
<code>fromJSON({json})</code>

<h2>XcGm3dCircle</h2>
<code>class XcGm3dCircle extends XcGm3dCurve</code>

<h3>radius</h3>
<code>get radius()</code>

<dl>
  <dt>return</dt>
  <dd>Return the radius value.</dd>
</dl>
Return the radius of the object.

<h3>XcGmEulerAngles</h3>
// TODO

<h3>coordinateSystem</h3>
<code>get coordinateSystem()</code>

<dl>
  <dt>return</dt>
  <dd><code>XcGmCoordinateSystem</code> object.</dd>
</dl>
Return <code>XcGmCoordinateSystem</code> object of the object.

<h3>create</h3>
<code>static create({radius, coordinateSystem})</code>

<dl>
  <dt>radius</dt>
  <dd>Radius value.</dd>
  <dt>coordinateSystem</dt>
  <dd>XcGmCoordinateSystem object of the object.</dd>
  <dt>return</dt>
  <dd>XcGm3dCircle object</dd>
</dl>
Create a XcGm3dCircle object from provided radius and coordinate system.

<h2>XcGm3dEllipse</h2>
<code>class XcGm3dEllipse extends XcGm3dCurve</code>

Represents a 3D Ellipse.

<h2>XcGm3dCurve</h2>
<code>class XcGm3dCurve extends XcGmGeometry</code>

<h3>makeWireBodyFromCurves</h3>
<code>static makeWireBodyFromCurves({curves, bounds})</code>

Example
<pre><code>      let position = new XcGm3dPosition();
      let direction = new XcGm3dVector({x: 1, y: 1, z: 0});
      let axis = new XcGm3dAxis({position, direction});
      let line = XcGm3dLine.create({axis});
      let bound = new XcGmInterval({low: 0, high: 10})});
      let {wire} = XcGm3dCurve.makeWireBodyFromCurves({curves: [line], bounds: [bound]});
</code></pre>

<h2>XcGm3dLine</h2>
<code>class XcGm3dLine extends XcGm3dCurve</code>

Represents a 3D line.

<h3>axis</h3>
<code>get axis()</code>

<dl>
  <dt>return</dt>
  <dd><code>XcGm3dAxis</code> object representing the axis of the 3D line.</dd>
</dl>
Get the axis of the 3D line.

<h3>create</h3>
<code>static create({axis})</code>

<dl>
  <dt>axis</dt>
  <dd><code>XcGm3dAxis</code> object representing the axis of the 3D line.</dd>
  <dt>return</dt>
  <dd><code>XcGm3dLine</code> object.</dd>
</dl>
Creates a XcGm3dLine object from the provided axis.

<h2>XcGm3dMatrix</h2>
<code>class XcGm3dMatrix</code>

Represents a 3D matrix, which is a 4 by 4 matrix.

<h3>identity</h3>
<code>static get identity()</code>

<dl>
  <dt>return</dt>
  <dd>XcGm3dMatrix object</dd>
</dl>
Constructs a 4 by 4 identity matrix.

<h3>fromArray</h3>
<code>static fromArray({array})</code>

<dl>
  <dt>array</dt>
  <dd>Array representation of the matrix.</dd>
  <dt>return</dt>
  <dd>XcGm3dMatrix object.</dd>
</dl>
Constructs a <code>XcGm3dMatrix</code> object from the array representation.

<h3>multiply</h3>
<code>static multiply({matrix1, matrix2})</code>

<dl>
  <dt>matrix1</dt>
  <dd>First matrix.</dd>
  <dt>matrix2</dt>
  <dd>Second matrix.</dd>
  <dt>return</dt>
  <dd>XcGm3dMatrix object</dd>
</dl>
Constructs a <code>XcGm3dMatrix</code> object from <code>matrix1 x matrix2</code>.

<h3>translationMatrix</h3>
<code>static translationMatrix({vector})</code>

<dl>
  <dt>vector</dt>
  <dd>XcGm3dVector object.</dd>
  <dt>return</dt>
  <dd>XcGm3dMatrix object</dd>
</dl>
Constructs a <code>XcGm3dMatrix</code> object representing a translation.

<h3>rotationMatrix</h3>
<code>static rotationMatrix({angle, axis})</code>

<dl>
  <dt>angle</dt>
  <dd>A floating point number representing rotation angle.</dd>
  <dt>axis</dt>
  <dd>XcGm3dAxis representing rotation axis.</dd>
  <dt>return</dt>
  <dd>XcGm3dMatrix object</dd>
</dl>
Constructs a <code>XcGm3dMatrix</code> object representing a rotation around an axis.

<h3>scalingMatrix</h3>
<code>static scalingMatrix({scale, center})</code>

<dl>
  <dt>scale</dt>
  <dd>A floating point number representing scaling factor.</dd>
  <dt>center</dt>
  <dd>XcGm3dPosition representing scale center.</dd>
  <dt>return</dt>
  <dd>XcGm3dMatrix object</dd>
</dl>
Constructs a <code>XcGm3dMatrix</code> object representing a scale relative to the center.

<h3>mirroringOverPositionMatrix</h3>
<code>static mirroringOverPositionMatrix({position})</code>

<dl>
  <dt>position</dt>
  <dd>XcGm3dPosition representing mirror position.</dd>
  <dt>return</dt>
  <dd>XcGm3dMatrix object</dd>
</dl>
Constructs a <code>XcGm3dMatrix</code> object representing a mirror transform relative to the position.

<h3>mirroringOverPlaneMatrix</h3>
<code>static mirroringOverPlaneMatrix({line})</code>

<dl>
  <dt>line</dt>
  <dd>XcGm3dAxis representing mirror line.</dd>
  <dt>return</dt>
  <dd>XcGm3dMatrix object</dd>
</dl>
Constructs a <code>XcGm3dMatrix</code> object representing a mirror transform relative to the line.

<h3>fromThreeMatrix4</h3>
<code>static fromThreeMatrix4({threeMatrix4})</code>
//TODO

<h3>rotationMatrixFromEulerAngles</h3>
<code>static rotationMatrixFromEulerAngles({eulerAngles})</code>

<h3>setToThreeMatrix4</h3>
<code>setToThreeMatrix4({threeMatrix4})</code>

<h3>setToRotationMatrixFromEulerAngles</h3>
<code>setToRotationMatrixFromEulerAngles({eulerAngles})</code>

<h3>toArray</h3>
<code>toArray()</code>

<dl>
  <dt>return</dt>
  <dd>Array representation of the object.</dd>
</dl>

<h3>toJSON</h3>
<code>toJSON()</code>

<dl>
  <dt>return</dt>
  <dd>Json representation of the object.</dd>
</dl>

<h3>clone</h3>
<code>clone()</code>

<dl>
  <dt>return</dt>
  <dd><code>XcGm3dMatrix</code> object which is cloned from the object.</dd>
</dl>

<h3>copy</h3>
<code>copy({matrix})</code>

<dl>
  <dt>matrix</dt>
  <dd><code>XcGm3dMatrix</code> object.</dd>
</dl>
Set the object value from another <code>XcGm3dMatrix</code> object.

<h3>get</h3>
<code>get({row, column})</code>

<dl>
  <dt>row</dt>
  <dd>Integer number representing the row index.</dd>
  <dt>column</dt>
  <dd>Integer number representing the column index.</dd>
  <dt>return</dt>
  <dd>A floating point number representing the matrix element value.</dd>
</dl>
Get the matrix element value at the <code>[row, column]</code>.

<h3>setToIdentity</h3>
<code>setToIdentity()</code>

Set this matrix to identity.

<h3>multiplyScalar</h3>
<code>multiplyScalar({scale})</code>

<dl>
  <dt>scale</dt>
  <dd>A floating point number representing scaling factor</dd>
</dl>
Scale the matrix using the provided factor.

<h3>multiply</h3>
<code>multiply({matrix})</code>

<dl>
  <dt>matrix</dt>
  <dd><code>XcGm3dMatrix</code> object.</dd>
</dl>
Do this × matrix.

<h3>preMultiply</h3>
<code>preMultiply({matrix})</code>

<dl>
  <dt>matrix</dt>
  <dd><code>XcGm3dMatrix</code> object.</dd>
</dl>
Do matrix × this.

<h3>setToProduct</h3>
<code>setToProduct({matrix1, matrix2})</code>

<dl>
  <dt>matrix1</dt>
  <dd><code>XcGm3dMatrix</code> object.</dd>
  <dt>matrix2</dt>
  <dd><code>XcGm3dMatrix</code> object.</dd>
</dl>
Set the object value to the product of the provided matrix1 and matrix2.

<h3>invert</h3>
<code>invert()</code>

Invert this matrix.

<h3>inverse</h3>
<code>get inverse()</code>

<dl>
  <dt>return</dt>
  <dd><code>XcGm3dMatrix</code> object.</dd>
</dl>
Return the inverse of this matrix.

<h3>isSingular</h3>
<code>isSingular()</code>

<dl>
  <dt>return</dt>
  <dd>Boolean value to indicate if the matrix is singular.</dd>
</dl>

<h3>transpose</h3>
<code>transpose()</code>

Transpose the matrix.

<h3>transposition</h3>
<code>transposition()</code>

<dl>
  <dt>return</dt>
  <dd><code>XcGm3dMatrix</code> object.</dd>
</dl>
Return the transposition of the object.

<h3>isEqualTo</h3>
<code>isEqualTo({matrix})</code>

<dl>
  <dt>return</dt>
  <dd>Boolean value to indicate if the matrix is equal to the provided matrix.</dd>
</dl>
Check if this matrix is equal to another matrix.

<h3>determinant</h3>
<code>determinant()</code>

<dl>
  <dt>return</dt>
  <dd>A floating number representing matrix determinant.</dd>
</dl>
Calculate the determinant value.

<h3>setTranslationVector</h3>
<code>setTranslationVector({vector})</code>

<dl>
  <dt>vector</dt>
  <dd><code>XcGm3dVector</code> object representing the translation vector.</dd>
</dl>
Set the translation part values of the matrix.

<h3>translationVector</h3>
<code>translationVector()</code>

<dl>
  <dt>return</dt>
  <dd><code>XcGm3dVector</code> object representing the translation vector.</dd>
</dl>
Get the translation part of the matrix.

<h3>setToTranslation</h3>
<code>setToTranslation({vector})</code>

<dl>
  <dt>vector</dt>
  <dd><code>XcGm3dVector</code> object representing the translation vector.</dd>
</dl>
Set the matrix representing a translation.

<h3>setToRotation</h3>
<code>setToRotation({angle, axis})</code>

<dl>
  <dt>angle</dt>
  <dd>A floating number representing the rotation angle.</dd>
  <dt>axis</dt>
  <dd><code>XcGm3dAxis</code> object representing the rotation axis.</dd>
</dl>
Set the matrix representing a rotation.

<h3>setToNonUniformScaling</h3>
<code>setToNonUniformScaling({scaleX, scaleY, scaleZ, center})</code>

<dl>
  <dt>scaleX</dt>
  <dd>A floating number representing the scaling factor on X.</dd>
  <dt>scaleY</dt>
  <dd>A floating number representing the scaling factor on Y.</dd>
  <dt>scaleZ</dt>
  <dd>A floating number representing the scaling factor on Z.</dd>
  <dt>center</dt>
  <dd><code>XcGm3dPosition</code> object representing the scaling center.</dd>
</dl>
Set the matrix representing a non-uniform scaling.

<h3>setToScaling</h3>
<code>setToScaling({scale, center})</code>

<dl>
  <dt>scale</dt>
  <dd>A floating number representing the scaling factor.</dd>
  <dt>center</dt>
  <dd><code>XcGm3dPosition</code> object representing the scaling center.</dd>
</dl>
Set the matrix representing a uniform scaling.

<h3>toThreeMatrix4</h3>
<code>toThreeMatrix4()</code>

<dl>
  <dt>return</dt>
  <dd>A Three.js matrix4</dd>
</dl>
Get the Three.js matrix representation of the object.

<h3>lerpTo</h3>
<code>lerpTo({targetMatrix, scale})</code>

<dl>
  <dt>return</dt>
  <dd>A linear interpolation of between the current matrix to the target matrix.</dd>
  <dt>targetMatrix</dt>
  <dd>target matrix</dd>
  <dt>scale</dt>
  <dd>the interpolation parameter, expected range from 0 to 1, the result is a weighted
    average.
    If scale=0, the result is the current matrix;
    if scale=1, the result is targetMatrix
  </dd>
</dl>
linear interpolation of position and orientation. The matrices are assumed to be rigid transform matrices, i.e.
rotation
and translation only

<h2>XcGm3dPoint</h2>
<code>class XcGm3dPoint extends XcGmGeometry</code>

<h3>constructor()</h3>
<code>constructor()</code>

<h3>position</h3>
<code>get position()</code>

<dl>
  <dt>return</dt>
  <dd><code>XcGm3dPosition</code> object of the point object.</dd>
</dl>
Get the position of the object.

<h3>part</h3>
<code>get part()</code>

<dl>
  <dt>return</dt>
  <dd><code>XcGmPart</code> object of the point object.</dd>
</dl>
This function returns the part which owns the given point, if there is one, otherwise null.
The point may either be attached directly to a vertex of a body, or be construction geometry in a part.

<h3>vertex</h3>
<code>get vertex()</code>

<h3>create</h3>
<code>static create({position})</code>

<h3>createMinimumBody</h3>
<code>createMinimumBody()</code>

<h2>XcGm3dPosition</h2>
<code>class XcGm3dPosition</code>

<h3>constructor</h3>
<code>constructor({x = 0.0, y = 0.0, z = 0.0} = {})</code>

<dl>
  <dt>x</dt>
  <dd>A floating number representing X coordinate.</dd>
  <dt>y</dt>
  <dd>A floating number representing Y coordinate.</dd>
  <dt>z</dt>
  <dd>A floating number representing Z coordinate.</dd>
</dl>

<h3>origin</h3>
<code>static get origin()</code>

<dl>
  <dt>return</dt>
  <dd>A new <code>XcGm3dPosition</code> object at the origin.</dd>
</dl>

<h3>fromArray</h3>
<code>static fromArray({array})</code>

<dl>
  <dt>array</dt>
  <dd>Array in the <code>[x, y, z]</code> form.</dd>
  <dt>return</dt>
  <dd>XcGm3dPosition object.</dd>
</dl>
Constructs a <code>XcGm3dPosition</code> object from an array.

<h3>fromJSON</h3>
<code>static fromJSON({json})</code>

<dl>
  <dt>json</dt>
  <dd>json object in the <code>{x, y}</code> form.</dd>
  <dt>return</dt>
  <dd><code>XcGm3dPosition</code> object.</dd>
</dl>
Constructs a <code>XcGm3dPosition</code> object from a json object.

<h3>add</h3>
<code>static add({position, vector})</code>

<dl>
  <dt>position</dt>
  <dd><code>XcGm3dPosition</code> object.</dd>
  <dt>vector</dt>
  <dd><code>XcGm3dVector</code> object.</dd>
  <dt>return</dt>
  <dd>A <code>XcGm3dPosition</code> object representing the <code>position + vector</code>.</dd>
</dl>

<h3>subtract</h3>
<code>static subtract({position, positionOrVector})</code>

<dl>
  <dt>position</dt>
  <dd><code>XcGm3dPosition</code> object.</dd>
  <dt>positionOrVector</dt>
  <dd><code>XcGm3dVector</code> or <code>XcGm3dPosition</code> object.</dd>
  <dt>return</dt>
  <dd>A <code>XcGm3dPosition</code> object representing the <code>position -
    positionOrVector</code>.
  </dd>
</dl>

<h3>multiply</h3>
<code>static multiply({position, scale})</code>

<dl>
  <dt>position</dt>
  <dd><code>XcGm3dPosition</code> object.</dd>
  <dt>scale</dt>
  <dd>A floating representing scaling factor.</dd>
  <dt>return</dt>
  <dd>A <code>XcGm3dPosition</code> object representing the <code>position * scale</code>.</dd>
</dl>

<h3>divide</h3>
<code>static divide({position, scale})</code>

<dl>
  <dt>position</dt>
  <dd><code>XcGm3dPosition</code> object.</dd>
  <dt>scale</dt>
  <dd>A floating representing scaling factor.</dd>
  <dt>return</dt>
  <dd>A <code>XcGm3dPosition</code> object representing the <code>position / scale</code>.</dd>
</dl>

<h3>fromThreeVector3</h3>
<code>static fromThreeVector3({threeVector3})</code>

<dl>
  <dt>threeVector3</dt>
  <dd>Three.js Vector3 object.</dd>
  <dt>return</dt>
  <dd>XcGm3dPosition object</dd>
</dl>
Constructs a <code>XcGm3dPosition</code> object from a Three.js Vector3 object.

<h3>toThreeVector3</h3>
<code>toThreeVector3()</code>

<dl>
  <dt>return</dt>
  <dd>Three.js Vector3 object.</dd>
</dl>
Constructs a Three.js Vector3 object representing the object.

<h3>toString</h3>
<code>toString()</code>

<dl>
  <dt>return</dt>
  <dd>String representation of the object.</dd>
</dl>

<h3>toArray</h3>
<code>toArray()</code>

<dl>
  <dt>return</dt>
  <dd>Array representation of the object.</dd>
</dl>

<h3>toJSON</h3>
<code>toJSON()</code>

<dl>
  <dt>return</dt>
  <dd>Json representation of the object.</dd>
</dl>

<h3>clone</h3>
<code>clone()</code>

<dl>
  <dt>return</dt>
  <dd><code>XcGm3dPosition</code> object which is cloned from the object.</dd>
</dl>

<h3>copy</h3>
<code>copy({position})</code>

<dl>
  <dt>position</dt>
  <dd><code>XcGm3dPosition</code> object.</dd>
</dl>
Set the object value from another <code>XcGm3dPosition</code> object.

<h3>add</h3>
<code>add({vector})</code>

<dl>
  <dt>vector</dt>
  <dd><code>XcGm3dVector</code> object.</dd>
</dl>
Add the object to the given vector.

<h3>subtract</h3>
<code>subtract({positionOrVector})</code>

<dl>
  <dt>positionOrVector</dt>
  <dd><code>XcGm3dVector</code> or <code>XcGm3dPosition</code> object.</dd>
</dl>
Subtract the object to the given position or vector.

<h3>multiply</h3>
<code>multiply({scale})</code>

<dl>
  <dt>scale</dt>
  <dd>A floating representing scaling factor.</dd>
</dl>
Multiply the object to the given scaling factor.

<h3>divide</h3>
<code>divide({scale})</code>

<dl>
  <dt>scale</dt>
  <dd>A floating representing scaling factor.</dd>
</dl>
Divide the object to the given scaling factor.

<h3>toVector</h3>
<code>toVector()</code>

<dl>
  <dt>return</dt>
  <dd><code>XcGm3dVector</code> object which has the same X/Y/Z values.</dd>
</dl>

<h3>set</h3>
<code>set({x, y, z})</code>

<dl>
  <dt>x</dt>
  <dd>A floating number representing X coordinate.</dd>
  <dt>y</dt>
  <dd>A floating number representing Y coordinate.</dd>
  <dt>z</dt>
  <dd>A floating number representing Z coordinate.</dd>
</dl>
Set the object value with the provided values.

<h3>setToSum</h3>
<code>setToSum({position, vector})</code>

<dl>
  <dt>position</dt>
  <dd><code>XcGm3dPosition</code> object.</dd>
  <dt>vector</dt>
  <dd><code>XcGm3dVector</code> object.</dd>
</dl>

<h3>setToProduct</h3>
<code>setToProduct({matrix, position})</code>

<dl>
  <dt>matrix</dt>
  <dd><code>XcGm3dMatrix</code> object.</dd>
  <dt>position</dt>
  <dd><code>XcGm3dPosition</code> object.</dd>
</dl>
Set the object value to the product of the provided matrix and position.

<h3>transformBy</h3>
<code>transformBy({matrix})</code>

<dl>
  <dt>matrix</dt>
  <dd><code>XcGm3dMatrix</code> object</dd>
</dl>
Transform the object with the provided matrix.

<h3>distanceToPosition</h3>
<code>distanceToPosition({position})</code>

<dl>
  <dt>position</dt>
  <dd><code>XcGm3dPosition</code> object.</dd>
  <dt>return</dt>
  <dd>A floating number representing the distance between the object and the provided position.</dd>
</dl>

<h3>isEqualTo</h3>
<code>isEqualTo({position})</code>

<dl>
  <dt>position</dt>
  <dd><code>XcGm3dPosition</code> object.</dd>
  <dt>return</dt>
  <dd>Boolean value representing if the object is equal to the provided position.</dd>
</dl>

<h2>XcGm3dVector</h2>
<code>class XcGm3dVector</code>

This class represents a 3D vector.

<h3>constructor</h3>
<code>constructor({x = 0.0, y = 0.0, z = 0.0} = {})</code>

<dl>
  <dt>x</dt>
  <dd>A floating number representing X coordinate.</dd>
  <dt>y</dt>
  <dd>A floating number representing Y coordinate.</dd>
  <dt>z</dt>
  <dd>A floating number representing Z coordinate.</dd>
</dl>

<h3>identity</h3>
<code>static get identity()</code>

<dl>
  <dt>return</dt>
  <dd><code>XcGm3dVector</code> vector.</dd>
</dl>
Return a new <code>XcGm3dVector({x: 0.0, y: 0.0, z: 0.0})</code>.

<h3>xAxis</h3>
<code>static get xAxis()</code>

<dl>
  <dt>return</dt>
  <dd><code>XcGm3dVector</code> vector.</dd>
</dl>
Return a new XcGm3dVector({x: 1.0, y: 0.0, z: 0.0})

<h3>yAxis</h3>
<code>static get yAxis()</code>

<dl>
  <dt>return</dt>
  <dd><code>XcGm3dVector</code> vector.</dd>
</dl>
Return a new XcGm3dVector({x: 0.0, y: 1.0, z: 0.0})

<h3>zAxis</h3>
<code>static get zAxis()</code>

<dl>
  <dt>return</dt>
  <dd><code>XcGm3dVector</code> vector.</dd>
</dl>
Return a new XcGm3dVector({x: 0.0, y: 0.0, z: 1.0})

<h3>fromArray</h3>
<code>static fromArray({array})</code>

<dl>
  <dt>array</dt>
  <dd>Array in the <code>[x, y, z]</code> form.</dd>
  <dt>return</dt>
  <dd>XcGm#DVector object</dd>
</dl>
Constructs a <code>XcGm3dVector</code> object from an array.

<h3>fromJSON</h3>
<code>static fromJSON({json})</code>

<dl>
  <dt>json</dt>
  <dd>json object in the <code>{x, y, z}</code> form.</dd>
  <dt>return</dt>
  <dd>XcGm3dVector object</dd>
</dl>
Constructs a <code>XcGm3dVector</code> object from a json object.

<h3>fromThreeVector3</h3>
<code>static fromThreeVector3({threeVector3})</code>

<dl>
  <dt>threeVector3</dt>
  <dd>Three.js Vector3 object.</dd>
  <dt>return</dt>
  <dd>XcGm3dVector object</dd>
</dl>
Constructs a <code>XcGm3dVector</code> object from a Three.js Vector3 object.

<h3>toString</h3>
<code>toString()</code>

<dl>
  <dt>return</dt>
  <dd>String representation of the object.</dd>
</dl>

<h3>toArray</h3>
<code>toArray()</code>

<dl>
  <dt>return</dt>
  <dd>Array representation of the object.</dd>
</dl>

<h3>toJSON</h3>
<code>toJSON()</code>

<dl>
  <dt>return</dt>
  <dd>Json representation of the object.</dd>
</dl>

<h3>clone</h3>
<code>clone()</code>

<dl>
  <dt>return</dt>
  <dd><code>XcGm3dVector</code> object which is cloned from the object.</dd>
</dl>

<h3>copy</h3>
<code>copy({vector})</code>

<dl>
  <dt>vector</dt>
  <dd><code>XcGm3dVector</code> object.</dd>
</dl>
Set the object value from another <code>XcGm3dVector</code> object.

<h3>add</h3>
<code>static add({vector1, vector2})</code>

<dl>
  <dt>vector1</dt>
  <dd><code>XcGm3dVector</code> object.</dd>
  <dt>vector2</dt>
  <dd><code>XcGm3dVector</code> object.</dd>
  <dt>return</dt>
  <dd><code>XcGm3dVector</code> object.</dd>
</dl>
Get a <code>XcGm3dVector</code> object representing <code>vector1</code> + <code>vector2</code>.

<h3>subtract</h3>
<code>static subtract({vector1, vector2})</code>

<dl>
  <dt>vector1</dt>
  <dd><code>XcGm3dVector</code> object.</dd>
  <dt>vector2</dt>
  <dd><code>XcGm3dVector</code> object.</dd>
  <dt>return</dt>
  <dd><code>XcGm3dVector</code> object.</dd>
</dl>
Get a <code>XcGm3dVector</code> object representing <code>vector1</code> - <code>vector2</code>.

<h3>multiply</h3>
<code>static multiply({vector, scale})</code>

<dl>
  <dt>vector</dt>
  <dd><code>XcGm3dVector</code> object.</dd>
  <dt>scale</dt>
  <dd>A floating representing scaling factor.</dd>
  <dt>return</dt>
  <dd><code>XcGm3dVector</code> object.</dd>
</dl>
Get a <code>XcGm3dVector</code> object representing <code>vector * scale</code>.

<h3>divide</h3>
<code>static divide({vector, scale})</code>

<dl>
  <dt>vector</dt>
  <dd><code>XcGm3dVector</code> object.</dd>
  <dt>scale</dt>
  <dd>A floating representing scaling factor.</dd>
  <dt>return</dt>
  <dd><code>XcGm3dVector</code> object.</dd>
</dl>
Get a <code>XcGm3dVector</code> object representing <code>vector / scale</code>.

<h3>add</h3>
<code>add({vector})</code>

<dl>
  <dt>vector</dt>
  <dd><code>XcGm3dVector</code> object.</dd>
</dl>
Add the object to the given vector.

<h3>subtract</h3>
<code>subtract({vector})</code>

<dl>
  <dt>vector</dt>
  <dd><code>XcGm3dVector</code> object.</dd>
</dl>
Subtract the object to the given vector.

<h3>multiply</h3>
<code>multiply({scale})</code>

<dl>
  <dt>scale</dt>
  <dd>A floating representing scaling factor.</dd>
</dl>
Multiply the object to the given scaling factor.

<h3>divide</h3>
<code>divide({scale})</code>

<dl>
  <dt>scale</dt>
  <dd>A floating representing scaling factor.</dd>
</dl>
Divide the object to the given scaling factor.

<h3>negate</h3>
<code>negate()</code>

Negate the object.

<h3>negation</h3>
<code>negation()</code>

<dl>
  <dt>return</dt>
  <dd><code>XcGm3dVector</code> object.</dd>
</dl>
Get the negation of the object.

<h3>lengthSquared</h3>
<code>lengthSquared()</code>

<dl>
  <dt>return</dt>
  <dd>A floating number representing the length squared.</dd>
</dl>

<h3>dotProduct</h3>
<code>dotProduct({vector})</code>

<dl>
  <dt>vector</dt>
  <dd><code>XcGm3dVector</code> object.</dd>
  <dt>return</dt>
  <dd>A floating number representing dot product between this object and another vector.</dd>
</dl>

<h3>set</h3>
<code>set({x, y, z})</code>

<dl>
  <dt>x</dt>
  <dd>A floating number representing X coordinate.</dd>
  <dt>y</dt>
  <dd>A floating number representing Y coordinate.</dd>
  <dt>z</dt>
  <dd>A floating number representing Z coordinate.</dd>
</dl>
Set the object value with the provided values.

<h3>setToProduct</h3>
<code>setToProduct({matrix, vector})</code>

<dl>
  <dt>matrix</dt>
  <dd><code>XcGm3dMatrix</code> object.</dd>
  <dt>vector</dt>
  <dd><code>XcGm3dVector</code> object.</dd>
</dl>
Set the object value to the product of the provided matrix and vector.

<h3>transformBy</h3>
<code>transformBy({matrix})</code>

<dl>
  <dt>matrix</dt>
  <dd><code>XcGm3dMatrix</code> object</dd>
</dl>
Transform the object with the provided matrix.

<h3>perpendicularVector</h3>
<code>get perpendicularVector()</code>

<dl>
  <dt>return</dt>
  <dd><code>XcGm3dVector</code> object.</dd>
</dl>
Calculate a perpendicular vector of the vector, if the current vector is not the zero vector. Otherwise, the zero vector is returned.

<h3>angleTo</h3>
<code>angleTo({vector})</code>

<dl>
  <dt>vector</dt>
  <dd><code>XcGm3dVector</code> object.</dd>
  <dt>return</dt>
  <dd>A floating number representing the angle to the provided vector.</dd>
</dl>

<h3>rotationAngleTo</h3>
<code>rotationAngleTo({vector, axis})</code>

<dl>
  <dt>vector</dt>
  <dd><code>XcGm3dVector</code> object.</dd>
  <dt>axis</dt>
  <dd><code>XcGm3dAxis</code> object.</dd>
  <dt>return</dt>
  <dd>A floating number representing the angle to the provided vector.</dd>
</dl>

<h3>normal</h3>
<code>get normal()</code>

<dl>
  <dt>return</dt>
  <dd><code>XcGm3dVector</code> object representing the normal vector of the object.</dd>
</dl>

<h3>normalize</h3>
<code>normalize()</code>

Normalize the object.

<h3>length</h3>
<code>get length()</code>

<dl>
  <dt>return</dt>
  <dd>A floating number representing the length of the object.</dd>
</dl>

<h3>isUnitLength</h3>
<code>isUnitLength()</code>

<dl>
  <dt>return</dt>
  <dd>Boolean value to indicate if the object is unit length.</dd>
</dl>

<h3>isZeroLength</h3>
<code>isZeroLength()</code>

<dl>
  <dt>return</dt>
  <dd>Boolean value to indicate if the object is zero length.</dd>
</dl>

<h3>isParallelTo</h3>
<code>isParallelTo({vector})</code>

<dl>
  <dt>vector</dt>
  <dd><code>XcGm3dVector</code> object to check.</dd>
  <dt>return</dt>
  <dd>Boolean value to indicate if the object is parallel to the given vector.</dd>
</dl>

<h3>isCodirectionalTo</h3>
<code>isCodirectionalTo({vector})</code>

<dl>
  <dt>vector</dt>
  <dd><code>XcGm3dVector</code> object to check.</dd>
  <dt>return</dt>
  <dd>Boolean value to indicate if the object is co-directional to the given vector.</dd>
</dl>

<h3>isPerpendicularTo</h3>
<code>isPerpendicularTo({vector})</code>

<dl>
  <dt>vector</dt>
  <dd><code>XcGm3dVector</code> object to check.</dd>
  <dt>return</dt>
  <dd>Boolean value to indicate if the object is perpendicular to the given vector.</dd>
</dl>

<h3>isEqualTo</h3>
<code>isEqualTo({vector})</code>

<dl>
  <dt>vector</dt>
  <dd><code>XcGm3dVector</code> object to check.</dd>
  <dt>return</dt>
  <dd>Boolean value to indicate if the object is equal to the given vector.</dd>
</dl>

<h3>crossProduct</h3>
<code>crossProduct({vector})</code>

<dl>
  <dt>vector</dt>
  <dd><code>XcGm3dVector</code> object.</dd>
  <dt>return</dt>
  <dd>A <code>XcGm3dVector</code> object representing <code>this X vector</code>.</dd>
</dl>

<h3>toThreeVector3</h3>
<code>toThreeVector3()</code>

<dl>
  <dt>return</dt>
  <dd>A Three.js vector3 representation.</dd>
</dl>

<h2>XcGmAssembly</h2>
<code>class XcGmAssembly extends XcGmPart</code>

<h3>constructor</h3>
<code>constructor()</code>

<h3>parts</h3>
<code>get parts()</code>

<h3>create</h3>
<code>static create()</code>

<h3>instances</h3>
<code>instances()</code>

Return XcGmInstance objects

<h3>partsAndTransfs</h3>
<code>partsAndTransfs()</code>

<h3>transformBy</h3>
<code>transformBy({matrix})</code>

<h3>makeLevelAssembly</h3>
<code>makeLevelAssembly()</code>

<h2>XcGm3dAxis</h2>
<code>class XcGm3dAxis</code>

<h3>position</h3>
<code>position</code>

XcGm3dPosition object

<h3>direction</h3>
<code>direction</code>

XcGm3dVector object

<h3>constructor</h3>
<pre><code>constructor({
                position = new XcGm3dPosition(),
                direction = new XcGm3dVector({x: 0, y: 0, z: 1})
              } = {})
</code></pre>

<h3>toJSON</h3>
<code>toJSON()</code>

<h3>fromJSON</h3>
<code>fromJSON({json})</code>

<h2>XcGmBlendSurface</h2>
<code>class XcGmBlendSurface extends XcGmSurface</code>

<h3>constructor</h3>
<code>constructor() { super(); }</code>

<h2>XcGmBody</h2>
<code>class XcGmBody extends XcGmPart</code>

<h3>BODY_TYPE</h3>
<pre><code>  static BODY_TYPE = {
    MINIMUM: 5603,
    ACORN: 5606,
    WIRE: 5604,
    SHEET: 5602,
    SOLID: 5601,
    GENERAL: 5605,
    UNSPECIFIED: 5607,
    EMPTY: 5608,
    COMPOUND: 5609
  };
</code></pre>

<h3>BooleanFunction</h3>
<pre><code>  static BooleanFunction = {
    Intersection: 15901, /* intersect */
    Subtraction: 15902, /* subtract */
    Union: 15903 /* unite */
  };
</code></pre>

<h3>constructor</h3>
<code>constructor()</code>

<h3>faces</h3>
<code>get faces()</code>

<h3>edges</h3>
<code>get edges()</code>

Return XcGmEdge

<h3>vertices</h3>
<code>get vertices()</code>

Return XcGmVertex

<h3>type</h3>
<code>get type()</code>

Return XcGmBody.BODY_TYPE

<h3>createSolidBlock</h3>
<code>static createSolidBlock({x, y, z, coordinateSystem = new XcGmCoordinateSystem()})</code>

Return XcGmBody

<h3>createSolidCone</h3>
<code>static createSolidCone({radius, height, semiAngle, coordinateSystem = new XcGmCoordinateSystem()})</code>

<h3>createSolidCylinder</h3>
<code>static createSolidCylinder({radius, height, coordinateSystem = new XcGmCoordinateSystem()})</code>

<h3>createSolidPrism</h3>
<code>static createSolidPrism({radius, height, sides, coordinateSystem = new XcGmCoordinateSystem()})</code>

<h3>createSolidSphere</h3>
<code>static createSolidSphere({radius, coordinateSystem = new XcGmCoordinateSystem()})</code>

<h3>createSolidTorus</h3>
<code>static createSolidTorus({majorRadius, minorRadius, coordinateSystem = new XcGmCoordinateSystem()})</code>

<h3>createSheetCircle</h3>
<code>static createSheetCircle({radius, coordinateSystem = new XcGmCoordinateSystem()})</code>

<h3>extrudeAlong</h3>
<code>extrudeAlong({direction, options})</code>

Example
<pre><code>        let myBody = ....;
        let direction = new XcGm3dVector({x: 0, y: 0, z: 1});
        let extrudedBody = myBody.extrudeAlong({
          direction: direction,
          options: {
            distance: 1
          }
        });
</code></pre>

<h3>spin</h3>
<code>spin({axis, angle})</code>

<dl>
  axis XcGm3dAxis object</dd>
</dl>
Example:
<pre><code>    let axis = ...;
    this.#profileBody.spin({axis, angle: Math.PI});
</code></pre>

<h3>transformBy</h3>
<code>transformBy({matrix})</code>

<h3>boolean</h3>
<code>boolean({tools, func})</code>

<dl>
  tools: XcGmBody objects</dd>
  func XcGmBody.BooleanFunction</dd>
</dl>
Return result bodies

<h3>fixBlends</h3>
<code>fixBlends()</code>

<h3>hollowFaces</h3>
<code>hollowFaces({faces, offset})</code>

<dl>
  faces: XcGmFace</dd>
  offset: A floating point number</dd>
</dl>

<h3>imprintCurve</h3>
<code>imprintCurve({curve, bounds})</code>

<h3>findVertexByPosition</h3>
<code>findVertexByPosition({position})</code>

Return XcGmVertex

<h3>findEdgeByPositions</h3>
<code>findEdgeByPositions({positions})</code>

<h3>findEdgeByVertices</h3>
<code>findEdgeByVertices({vertex1, vertex2})</code>

<h3>findFaceByPositions</h3>
<code>findFaceByPositions({positions})</code>

<h3>findFaceByEdges</h3>
<code>findFaceByEdges({edges})</code>

<h3>findFaceByVertices</h3>
<code>findFaceByVertices({vertices})</code>

<h3>findVertexWithFilter</h3>
<code>findVertexWithFilter({callback})</code>

<h3>findEdgeWithFilter</h3>
<code>findEdgeWithFilter({callback})</code>

<h3>findFaceWithFilter</h3>
<code>findFaceWithFilter({callback})</code>

<h2>XcGm3dBox</h2>
<code>class XcGm3dBox</code>

<h3>constructor</h3>
<code>constructor({minimumX, minimumY, minimumZ, maximumX, maximumY, maximumZ})</code>

<h3>fromJSON</h3>
<code>static fromJSON({json})</code>

<h3>toJSON</h3>
<code>toJSON()</code>

<h2>XcGmBSurface</h2>
<code>class XcGmBSurface extends XcGmSurface</code>

<h3>constructor</h3>
<code>constructor()</code>

<h3>XcGmCone</h3>
<code>class XcGmCone extends XcGmSurface</code>

<h3>constructor</h3>
<code>constructor()</code>

<h2>XcGmContext</h2>
<code>class XcGmContext</code>

<h3>gTol</h3>
<code>static gTol = new XcGmPrecision();</code>

<h3>constructor</h3>
<code>constructor()</code>

<h2>XcGmCoordinateSystem</h2>
<code>class XcGmCoordinateSystem</code>

<h3>origin</h3>
<code>origin</code>

XcGm3dPosition

<h3>zAxis</h3>
<code>zAxis</code>

XcGm3dVector

<h3>xAxis</h3>
<code>xAxis</code>

XcGm3dVector

<h3>constructor</h3>
<code>constructor({ origin = new XcGm3dPosition(), zAxis = new XcGm3dVector({x: 0, y: 0, z: 1}), xAxis = new
  XcGm3dVector({x: 1, y: 0, z: 0}) } = {})</code>

<h3>fromMatrix</h3>
<code>static fromMatrix({matrix})</code>

<h3>toMatrix</h3>
<code>toMatrix()</code>

<h3>transformToCoordinateSystem</h3>
<code>transformToCoordinateSystem({coordinateSystem})</code>

<h3>fromJSON</h3>
<code>static fromJSON({json})</code>

<h3>toJSON</h3>
<code>toJSON()</code>

<h3>XcGmCylinder</h3>
<code>class XcGmCylinder extends XcGmSurface</code>

<h3>constructor</h3>
<code>constructor()</code>

<h3>XcGmEdge</h3>
<code>class XcGmEdge extends XcGmTopology</code>

<h3>body</h3>
<code>get body()</code>

<h3>curve</h3>
<code>get curve()</code>

<h3>faces</h3>
<code>get faces()</code>

Return XcGmFace array

<h3>vertices</h3>
<code>get vertices()</code>

Return {vertex1, vertex2} where vertex1 and vertex2 are XcGmVertex

<h3>makeFacesFrom</h3>
<code>static makeFacesFrom({edges, senses, sharedLoop})</code>

<dl>
  Return XcGmFace array</dd>
</dl>
Example
<pre><code>
  let {wire, newEdges} = XcGm3dCurve.makeWireBodyFromCurves({curves, bounds});
  let faces = XcGmEdge.makeFacesFrom({edges: [newEdges[0].edge], senses: [true], sharedLoop: [-1]});
</code></pre>

<h3>setBlendConstantFor</h3>
<code>static setBlendConstantFor({edges, radius})</code>

<dl>
  Return blend edges.</dd>
</dl>
Example
<pre><code>
  let edges = ...;
  XcGmEdge.setBlendConstantFor({edges, radius: 0.01});
  myBody.fixBlends();
</code></pre>

<h3>findInterval</h3>
<code>findInterval()</code>

<dl>
  Return XcGmInterval</dd>
</dl>

<h3>containsVector</h3>
<code>containsVector({vector})</code>

<dl>
  Return XcGmTopology</dd>
</dl>
Example
<pre><code>
  let topol = edge.containsVector({vector});
  if (topol) {
    // The edge contains the vector
  }
</code></pre>

<h3>findVertexByPosition</h3>
<code>findVertexByPosition({position})</code>

<dl>
  Return null or XcGmVertex object found.</dd>
</dl>

<h3>findVertexWithFilter</h3>
<code>findVertexWithFilter({callback})</code>

<dl>
  callback filter function in the form of <code>callback(vertex[, index[, array]</code>])</dd>
  Return filtered array, which could be empty array.</dd>
</dl>

<h2>XcGmEntity</h2>
<code>class XcGmEntity</code>

<h3>tag</h3>
<code>tag</code>

A unique handle number

<h3>constructor</h3>
<code>constructor()</code>

<h3>getObjFromTag</h3>
<code>static getObjFromTag({entityTag})</code>

<h3>PKDelete</h3>
<code>static PKDelete({entity})</code>

<h3>toJSON</h3>
<code>toJSON()</code>

<h3>clone</h3>
<code>clone()</code>

<h2>XcGmFace</h2>
<code>class XcGmFace extends XcGmTopology</code>

<h3>constructor</h3>
<code>constructor()</code>

<h3>surf</h3>
<code>get surf()</code>

Return XcGmSurface

<h3>UVBox</h3>
<code>get UVBox()</code>

<dl>
  Return XcGmUVBox</dd>
</dl>

<h3>body</h3>
<code>get body()</code>

<dl>
  Return XcGmBody</dd>
</dl>

<h3>edges</h3>
<code>get edges()</code>

<dl>
  Return XcGmEdge array</dd>
</dl>

<h3>vertices</h3>
<code>get vertices()</code>

<dl>
  Return XcGmVertex array</dd>
</dl>

<h3>delete</h3>
<code>static delete({faces})</code>

<dl>
  faces XcGmFace array</dd>
</dl>
Delete faces from a body

<h3>transform</h3>
<code>static transform({facesAndMatrices, tolerance})</code>

<dl>
  facesAndMatrices Array of XcGmFace and XcGm3dMatrix</dd>
  tolerance floating number</dd>
</dl>
Example
<pre><code>        let face = ....;
        let matrix = ....;
        XcGmFace.transform({
          facesAndMatrices: [{face, matrix}],
          tolerance: 1e-5
        });
</code></pre>

<h3>surfAndOrientation</h3>
<code>surfAndOrientation()</code>

<dl>
  Return {surf, orientation}</dd>
</dl>
Example
<pre><code>      let face = ...;
      let {surf, orientation} = face.surfAndOrientation();
      if (surf instanceof XcGmPlane) {
        let coordinateSystem = surf.coordinateSystem;
        let faceDir = coordinateSystem.zAxisDirection;
        if (!orientation) {
          faceDir.negate();
        }
      }
</code></pre>

<h3>attachSurfFitting</h3>
<code>attachSurfFitting({localCheck})</code>

<dl>
  Return localCheckResult</dd>
</dl>
Example
<pre><code>      let {wire, newEdges} = XcGm3dCurve.makeWireBodyFromCurves({curves, bounds});
      let faces = XcGmEdge.makeFacesFrom({edges: [newEdges[0].edge], senses: [true], sharedLoop: [-1]});
      XcSysAssert({
        assertion: faces.length === 1,
        message: `Cannot generate sheet body. Single loop supported only`
      });
      let face = faces[0];
      let localCheckStatus = face.attachSurfFitting({localCheck: true});
      let faceBody = face.body;
</code></pre>

<h3>findVertexByPosition</h3>
<code>findVertexByPosition({position})</code>

<dl>
  position XcGm3dPosition</dd>
  Return XcGmVertex or null when not found</dd>
</dl>

<h3>findEdgeByVertex</h3>
<code>findEdgeByVertex(vertex)</code>

<dl>
  vertex XcGmVertex</dd>
  Return XcGmEdge array</dd>
</dl>

<h3>findEdgeByTwoVertices</h3>
<code>findEdgeByTwoVertices({vertex1, vertex2})</code>

<dl>
  vertex1 XcGmVertex</dd>
  vertex2 XcGmVertex</dd>
  Return XcGmEdge or null</dd>
</dl>

<h3>findVertexWithFilter</h3>
<code>findVertexWithFilter({callback})</code>

<dl>
  callback filter function in the form of <code>callback(vertex[, index[, array]</code>])</dd>
  Return filtered vertex array, which could be empty array.</dd>
</dl>

<h3>findEdgeWithFilter</h3>
`findEdgeWithFilter({callback})``
<dl>
  callback filter function in the form of <code>callback(edge[, index[, array]</code>])</dd>
  Return filtered edge array, which could be empty array.</dd>
</dl>

<h2>XcGmGeometry</h2>
<code>class XcGmGeometry extends XcGmEntity</code>

<h3>constructor</h3>
<code>constructor()</code>

<h2>XcGmInstance</h2>
<code>class XcGmInstance extends XcGmTopology</code>

<h3>constructor</h3>
<code>constructor()</code>

<h3>assembly</h3>
<code>get assembly()</code>

<dl>
  Return XcGmAssembly</dd>
</dl>

<h3>transform</h3>
<code>get transform()</code>

<dl>
  Return XcGm3dMatrix</dd>
</dl>

<h3>part</h3>
<code>get part()</code>

<dl>
  Return XcGmPart</dd>
</dl>

<h3>create</h3>
<code>static create({assembly, part, matrix = null})</code>

<dl>
  assembly XcGmAssembly</dd>
  part XcGmPart</dd>
  matrix null or XcGm3dMatrix</dd>
</dl>

<h3>changePart</h3>
<code>changePart({part})</code>

<dl>
  part XcGmPart</dd>
</dl>

<h3>replaceTransf</h3>
<code>replaceTransf({transf})</code>

<dl>
  transf XcGmTransf</dd>
</dl>

<h3>transformBy</h3>
<code>transformBy({matrix})</code>

<dl>
  matrix XcGm3dMatrix</dd>
</dl>

<h2>XcGmInterval</h2>
<code>class XcGmInterval</code>

<h3>low</h3>
<code>low</code>

<h3>high</h3>
<code>high</code>

<h3>constructor</h3>
<code>constructor({low, high})</code>

<h3>fromJSON</h3>
<code>static fromJSON({json})</code>

<h3>toJSON</h3>
<code>toJSON()</code>

<h2>XcGmLoop</h2>
<code>class XcGmLoop extends XcGmTopology</code>

<h3>constructor</h3>
<code>constructor()</code>

<h2>XcGmOffset</h2>
<code>class XcGmOffset extends XcGmSurface</code>

<h3>constructor</h3>
<code>constructor()</code>

<h2>XcGmPart</h2>
<code>class XcGmPart extends XcGmTopology</code>

<h3>constructor</h3>
<code>constructor()</code>

<h3>transmitToData</h3>
<code>static transmitToData({parts})</code>

<h3>transmitToFile</h3>
<code>static transmitToFile({parts, path})</code>

<h3>receiveFromData</h3>
<code>static receiveFromData({data})</code>

<h3>receiveFromFile</h3>
<code>static receiveFromFile({fileName})</code>

<h3>findEntityByIdent</h3>
<code>findEntityByIdent({identifier, cls})</code>

<h2>XcGmPK_CIRCLE_sf_t</h2>
<code>class XcGmPK_CIRCLE_sf_t</code>

<h3>radius</h3>
<code>radius</code>

<h3>basisSet</h3>
<code>basisSet</code>

XcGmPK_AXIS2_sf_t

<h3>constructor</h3>
<code>constructor({ radius, basisSet = new XcGmPK_AXIS2_sf_t() })</code>

<h3>toJSON</h3>
<code>toJSON()</code>

<h3>fromJSON</h3>
<code>static fromJSON({json})</code>

<h2>XcGmPK_LINE_sf_t</h2>
<code>class XcGmPK_LINE_sf_t</code>

<h3>basisSet</h3>
<code>basisSet</code>

XcGmPK_AXIS1_sf_t

<h3>constructor</h3>
<code>constructor(basisSet = new XcGmPK_AXIS1_sf_t())</code>

<h3>toJSON</h3>
<code>toJSON()</code>

<h3>fromJSON</h3>
<code>static fromJSON({json})</code>

<h2>XcGmPK_POINT_sf_t</h2>
<code>class XcGmPK_POINT_sf_t</code>

<h3>position</h3>
<code>position</code>

XcGm3dPosition

<h3>constructor</h3>
<code>constructor(position = new XcGm3dPosition())</code>

<h3>toJSON</h3>
<code>toJSON()</code>

<h3>fromJSON</h3>
<code>static fromJSON({json})</code>

<h2>XcGmPK_AXIS1_sf_t</h2>
<code>class XcGmPK_AXIS1_sf_t</code>

<h3>location</h3>
<code>location</code>

XcGm3dPosition

<h3>axis</h3>
<code>axis</code>

XcGm3dVector

<h3>constructor</h3>
<pre><code>  constructor({
                location = new XcGm3dPosition(),
                axis = new XcGm3dVector({x: 0, y: 0, z: 1})
              } = {})
</code></pre>

<h3>toJSON</h3>
<code>toJSON()</code>

<h3>fromJSON</h3>
<code>static fromJSON({json})</code>

<h2>XcGmPK_AXIS2_sf_t</h2>
<code>class XcGmPK_AXIS2_sf_t</code>

<h3>location</h3>
<code>location</code>

XcGm3dPosition

<h3>axis</h3>
<code>axis</code>

XcGm3dVector

<h3>refDirection</h3>
<code>refDirection</code>

XcGm3dVector

<h3>constructor</h3>
<code>constructor({ location = new XcGm3dPosition(), axis = new XcGm3dVector({x: 0, y: 0, z: 1}), refDirection = new
  XcGm3dVector({x: 1, y: 0, z: 0}) } = {})</code>

<h3>toJSON</h3>
<code>toJSON()</code>

<h3>fromJSON</h3>
<code>static fromJSON({json})</code>

<h2>XcGmPK_INSTANCE_sf_t</h2>
<code>class XcGmPK_INSTANCE_sf_t</code>

<h3>assembly</h3>
<code>assembly</code>

XcGmAssembly

<h3>transf</h3>
<code>transf</code>

XcGmPKTransf

<h3>part</h3>
XcGmPart

<h3>constructor</h3>
<code>constructor({ assembly = null, transf = null, part = null } = {})</code>
<code>part</code>

<h3>toJSON</h3>
<code>toJSON()</code>

<h3>fromJSON</h3>
<code>static fromJSON({json})</code>

<h2>XcGmPK_PLANE_sf_t</h2>
<code>class XcGmPK_PLANE_sf_t</code>

<h3>basisSet</h3>
<code>basisSet</code>

XcGmPK_AXIS2_sf_t

<h3>constructor</h3>
<code>constructor(basisSet = new XcGmPK_AXIS2_sf_t())</code>

<h3>toJSON</h3>
<code>toJSON()</code>

<h3>fromJSON</h3>
<code>static fromJSON({json})</code>

<h2>XcGmPK_SPHERE_sf_t</h2>
<code>class XcGmPK_SPHERE_sf_t</code>

<h3>radius</h3>
<code>radius</code>

<h3>basisSet</h3>
<code>basisSet</code>

XcGmPK_AXIS2_sf_t

<h3>constructor</h3>
<pre><code>  constructor({
                radius,
                basisSet = new XcGmPK_AXIS2_sf_t()
              })
</code></pre>

<h3>toJSON</h3>
<code>toJSON()</code>

<h3>fromJSON</h3>
<code>static fromJSON({json})</code>

<h2>XcGmTransf</h2>
<code>class XcGmTransf extends XcGmEntity</code>

<h3>constructor</h3>
<code>constructor()</code>

<h3>matrix</h3>
<code>get matrix()</code>

Return XcGm3dMatrix

<h3>create</h3>
<code>static create({transfSF})</code>

<dl>
  transfSF XcGmPK_TRANSF_sf_t</dd>
</dl>

<h2>XcGmPK_TRANSF_sf_t</h2>
<code>class XcGmPK_TRANSF_sf_t</code>

<h3>matrix</h3>
<code>matrix</code>

XcGm3dMatrix

<h3>toJSON</h3>
<code>toJSON()</code>

<h3>fromJSON</h3>
<code>static fromJSON({json})</code>

<h2>XcGmPlane</h2>
<code>class XcGmPlane extends XcGmSurface</code>

<h3>constructor</h3>
<code>constructor()</code>

<h3>coordinateSystem</h3>
<code>get coordinateSystem()</code>

Return XcGmCoordinateSystem

<h3>create</h3>
<code>static create({coordinateSystem})</code>

<h2>XcGmPrecision</h2>
<code>class XcGmPrecision</code>

<h3>linearPrecision</h3>
<code>linearPrecision</code>

<h3>anglePrecision</h3>
<code>anglePrecision</code>

<h3>constructor</h3>
<code>constructor({linearPrecision = 1.0e-8, anglePrecision = 1.0e-11} = {})</code>

<h2>XcGmSphere</h2>
<code>class XcGmSphere extends XcGmSurface</code>

<h3>constructor</h3>
<code>constructor()</code>

<h3>radius</h3>
<code>get radius()</code>

<h3>coordinateSystem</h3>
<code>get coordinateSystem()</code>

Return XcGmCoordinateSystem

<h3>create</h3>
<code>static create({radius, coordinateSystem})</code>

<h2>XcGmSpun</h2>
<code>class XcGmSpun extends XcGmSurface</code>

<h3>constructor</h3>
<code>constructor()</code>

<h2>XcGmSurface</h2>
<code>class XcGmSurface extends XcGmGeometry</code>

<h3>constructor</h3>
<code>constructor()</code>

<h3>evaluate</h3>
<code>evaluate({uv})</code>

<dl>
  uv XcGmUV</dd>
  Return XcGm3dPosition</dd>
</dl>

<h2>XcGmSwept</h2>
<code>class XcGmSwept extends XcGmSurface</code>

<h3>constructor</h3>
<code>constructor()</code>

<h2>XcGmTorus</h2>
<code>class XcGmTorus extends XcGmSurface</code>

<h3>constructor</h3>
<code>constructor()</code>

<h2>XcGmTopology</h2>
<code>class XcGmTopology extends XcGmEntity</code>

<h3>constructor</h3>
<code>constructor()</code>

<h3>box</h3>
<code>get box()</code>

Return XcGm3dBox

<h3>evalMassPropsFor</h3>
<code>static evalMassPropsFor({topols, accuracy})</code>

<dl>
  topols XcGmTopology object array</dd>
  accuracy Computational accuracy</dd>
  return {amount, mass, cog, mofi, periphery}</dd>
</dl>
Example
<pre><code>      let {cog} = XcGmTopology.evalMassPropsFor({topols: [myTopol], accuracy: 1});
</code></pre>

<h3>render</h3>
<code>render()</code>

<dl>
  return {allFaceRenderingData, allEdgeRenderingData, allVertexRenderingData}</dd>
</dl>

<h2>XcGmUV</h2>

<h3>u</h3>
<code>u</code>

<h3>v</h3>
<code>v</code>

<h3>constructor</h3>
<code>constructor({u, v})</code>

<h3>toJSON</h3>
<code>toJSON()</code>

<h3>fromJSON</h3>
<code>static fromJSON({json})</code>

<h2>XcGmUVBox</h2>
<code>class XcGmUVBox</code>

<h3>param</h3>
<code>param</code>

<h3>constructor</h3>
<code>constructor({lowU, lowV, highU, highV})</code>

<h3>toJSON</h3>
<code>toJSON()</code>

<h3>fromJSON</h3>
<code>static fromJSON({json})</code>

<h2>XcGmVertex</h2>
<code>class XcGmVertex extends XcGmTopology</code>

<h3>constructor</h3>
<code>constructor()</code>

<h3>point</h3>
<code>get point()</code>

Return XcGmPoint

<h3>body</h3>
<code>get body()</code>

Return XcGmBody

<h3>faces</h3>
<code>get faces()</code>

Return XcGmFace array


<h2>XcGmQuaternion</h2>
<code>class XcGmQuaternion</code>

<dl>
  Construct a quaternion.</dd>
  </dd>
  @param {*} the components of the quaternion to construct. The default is the unit.
  */
  </dd>
</dl>

<h3>constructor</h3>
<code>constructor({w = 1, x = 0, y = 0, z = 0} = {})</code>

<h3>fromRotationMatrix</h3>

<code>static fromRotationMatrix({matrix})</code>
*matrix a rotation matrix
Convert a rotation matrix to a unit quaternion
Assuming the input matrix is a pure rotation matrix:
any perspective factor or translation vector is ignored

<h3>conjugate</h3>
<code>conjugate()</code>

The inverse quaternion for a unit quaternion

<h3>multiply</h3>
<code>multiply({qRight})</code>

<dl>
  <dt>qRight</dt>
  <dd>the quaternion on the right</dd>
</dl>

Hamliton product. The multiplication order puts the current quaternion on the left

<h3>normalize</h3>
<code>normalize()</code>

Normalize the current quaternion. If the normal is zero within tolerance, no-op.

<h3>normal</h3>
<code>normal()</code>

A normalized quaternion from the current. The current is not changed

<h3>lengthSquared</h3>
<code>lengthSquared()</code>

The Squared length

<h3>pow</h3>
<code>pow({exponent})</code>

<dl>
  <dt>exponent</dt>
  <dd>the exponent</dd>
</dl>

The power function, assuming unit quaternions

<h3>lerpTo</h3>
<code>lerpTo({target, exponent})</code>

<dl>
  <dt>target</dt>
  <dd>the target unit quaternion for linear interpolation from the current</dd>
  <dt>exponent</dt>
  <dd>the interpolation parameter. If the parameter is 0, the interpolation result is the current quaterion.</dd>
</dl>
If the parameter is 1, the result is the target quaternion linear interpolation of two rotation quaterions: q0 to q1,
with parameter t: q0 * (q0’ * q1)^t, q0’ being the conjugate: q0’ = 1/q0 for unit quaternions;
<ul>
  <li>t=0, the result is q0;</li>
  <li>t=1, the result is q1;</li>
  <li>otherwise, the result is a linear interpolation</li>
</ul>

<h3>matrix</h3>
<code>get matrix()</code>
Conversion from the current quaternion to its corresponding rotation matrix.

<h3>fromTwoVectors</h3>
<code>static fromTwoVectors({fromVector, toVector})</code>
<dl>
  <dt>fromVector</dt>
  <dd>The XcGm3dVector to rotate from</dd>
  <dt>toVector</dt>
  <dd>The XcGm3dVector to rotate to</dd>
</dl>
Find the rotation to rotate a vector to another. If the two vectors are exactly on opposite directions or one vector is zero,
the rotation axis is up to implementation. The rotation is well defined in all other cases.

</body>
</html>
